{"version":3,"sources":["AlgoVisual/Layout/Header/Header.tsx","AlgoVisual/Layout/Footer/Footer.tsx","AlgoVisual/Layout/Main/Home/Home.tsx","AlgoVisual/Layout/Main/Documentation/Common/Markdown.tsx","AlgoVisual/Layout/Main/Documentation/Sections/Introduction/Introduction.tsx","AlgoVisual/Layout/Main/Documentation/Sections/Markdown/Markdown.ts","AlgoVisual/Layout/Main/Documentation/Common/Sections.tsx","AlgoVisual/Layout/Main/Documentation/Sections/DataStructures/DataStructures.tsx","AlgoVisual/Layout/Main/Documentation/Sections/Sorting/Sorting.tsx","AlgoVisual/Layout/Main/Documentation/Sections/Pathfinding/Pathfinding.tsx","AlgoVisual/Layout/Main/Documentation/Common/ScrollToTopNewPage.js","AlgoVisual/Layout/Main/Documentation/Common/NextSection.tsx","AlgoVisual/Layout/Main/Documentation/Common/MarkdownPage.tsx","AlgoVisual/Layout/Main/Documentation/Common/ScrollToTopButton.tsx","AlgoVisual/Layout/Main/Documentation/Layout/Documentation.tsx","AlgoVisual/Layout/Main/SortingVisualizer/Algorithms/BubbleSort.ts","AlgoVisual/Layout/Main/SortingVisualizer/Algorithms/MergeSort.ts","AlgoVisual/Layout/Main/SortingVisualizer/Algorithms/QuickSort.ts","AlgoVisual/Layout/Main/SortingVisualizer/Algorithms/HeapSort.ts","AlgoVisual/Layout/Main/SortingVisualizer/Algorithms/SelectionSort.ts","AlgoVisual/Layout/Main/SortingVisualizer/SortingVisualizer.tsx","AlgoVisual/Layout/Main/SortingVisualizer/Algorithms/InsertionSort.ts","AlgoVisual/Layout/Main/PathfindingVisualizer/Node/GridNode.tsx","AlgoVisual/Layout/Main/PathfindingVisualizer/Algorithms/IndexMinPQ.ts","AlgoVisual/Layout/Main/PathfindingVisualizer/Algorithms/DijkstraSP.ts","AlgoVisual/Layout/Main/PathfindingVisualizer/Algorithms/DFS.ts","AlgoVisual/Layout/Main/PathfindingVisualizer/Algorithms/BFS.ts","AlgoVisual/Layout/Main/PathfindingVisualizer/MazeGeneration/RecursiveDivision.ts","AlgoVisual/Layout/Main/PathfindingVisualizer/PathfindingVisualizer.tsx","AlgoVisual/App.tsx","Misc/reportWebVitals.ts","index.tsx"],"names":["Header","props","dropdownMenu","createRef","dropdownCaret","state","showAlgosMenu","bind","closeAlgosMenu","displayAlgosMenu","e","this","setState","stopPropagation","document","addEventListener","removeEventListener","current","style","display","transform","transition","id","to","className","onClick","ref","React","Component","Footer","href","target","Home","codeStyle","padding","margin","overflow","Markdown","children","markdown","remarkPlugins","remarkGfm","remarkBreaks","components","a","rel","em","startsWith","tex","String","substring","setting","code","inline","match","exec","replace","customStyle","themeStyle","showLineNumbers","language","PreTag","Introduction","section","borderLeft","backgroundColor","textDecoration","listStyle","listStyleType","fontSize","borderRadius","cursor","color","listBreakStyle","height","border","Sections","text","toLowerCase","sections","map","index","directory","linkify","sectionHighlight","length","wrapperStyle","width","DataStructures","Sorting","Pathfinding","withRouter","history","useEffect","unlisten","listen","window","scrollTo","endSectionStyle","marginTop","nextSectionStyle","nextSectionTextStyle","marginLeft","NextSection","sectionName","MarkdownPage","nextSection","nextSectionDirectory","nextSectionName","mainDirectory","partNumber","ScrollToTopButton","isVisible","scrollComponent","toggleVisibility","scrollY","top","behavior","scrollToTop","dataStructuresSections","sortingSections","pathfindingSections","Documentation","gettingStartedSection","dataStructuresSection","sortingSection","pathfindingSection","exact","path","getBubbleSortAnimations","arr","animations","i","count","j","push","swap","bubbleSort","temp","getMergeSortAnimations","array","auxiliaryArray","slice","mergeSort","mainArray","startIdx","endIdx","middleIdx","Math","floor","k","merge","getQuickSortAnimations","quickSort","l","h","swappedPivotIndex","pivotIndex","min","max","random","pivot","partition","getHeapSortAnimations","n","sink","heapSort","less","getSelectionSortAnimations","minIndex","selectionSort","PRIMARY_COLOR","SECONDARY_COLOR","options","SortingVisualizer","dropdownSelection","runButton","resetButton","timer","numberOfBars","sortingSpeed","sortingAlgorithm","showSortingOptions","optionsDisabled","animationLength","sliderStyle","boxShadow","bgcolor","keepTimeout","resetArray","changeWidthBasedOnSize","sliderSpeed","runSortingAlgorithm","buttonEnter","buttonLeave","showSortingAlgorithms","closeSortingAlgorithms","displaySortingAlgorithms","changeAlgorithm","screenHeight","getElementById","clientHeight","headerHeight","footerHeight","containerHeight","maxBarHeight","changeBarsWidth","arrayBars","getElementsByClassName","value","currentTarget","option","sort","key","insertionSort","getInsertionSortAnimations","quickSortAnimations","enableSettings","undefined","animationType","barOneIdx","barTwoIdx","barOne","barTwo","t","setTimeout","clearTimeout","newHeight","modulus","buttons","button","bars","idx","Slider","sx","disabled","onChange","defaultValue","valueLabelDisplay","onMouseEnter","onMouseLeave","GridNode","col","isFinish","isStart","isWall","onMouseDown","onMouseOver","onMouseUp","row","onTouchStart","onTouchMove","onTouchEnd","nodeID","IndexMinPQ","maxN","comparator","keys","pq","qp","swim","exch","console","log","greater","dijkstraSP","s","grid","gridDimensions","visitedNodes","weight","colSize","insert","getIndex","isEmpty","nodeIndex","delMin","minNode","Infinity","isVisited","neighbors","getNeighbors","relax","v","vIndex","contains","decreaseKey","unvisitedNeighbors","filter","neighbor","previousNode","dfsVisited","dfs","validVertex","unshift","recursiveDivision","walls","addOuterWalls","addInnerWalls","minX","maxX","minY","maxY","y","randomNumber","hole","addHWall","x","addVWall","PathfindingVisualizer","initialGrid","mouseIsPressed","rows","cols","algorithm","showAlgorithms","nodeStyle","closeAlgorithms","runAlgorithm","getInitialGrid","resizeGrid","root","ontouchmove","wallsGrid","changedTouches","element","elementFromPoint","clientX","clientY","classList","line","split","parseInt","onmousedown","preventDefault","onmouseup","stopImmediatePropagation","COLS","mainContentWidth","offsetWidth","dimension","displayAlgorithms","visualizeDFS","visualizeBFS","visualizeDijkstra","update","$set","newGrid","getNewGridWithWallToggled","startNode","finishNode","pathForDFS","shortestPath","currentNode","dfsPath","animateVisited","copyGrid","queue","node","shift","bfsVisited","pathForBFS","bfsPath","pathNodes","animatePath","getCopyGrid","currentRow","createNode","nodes","handleMouseDown","handleMouseEnter","clearGrid","handleMouseLeave","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.468bbb64.chunk.js","sourcesContent":["import React, {createRef} from \"react\";\nimport \"./Header.css\";\nimport {Link} from \"react-router-dom\"\n\ntype Props = {};\ntype State = {\n    showAlgosMenu: boolean\n};\n\nclass Header extends React.Component<Props, State> {\n    private dropdownMenu = createRef<HTMLDivElement>();\n    private dropdownCaret = createRef<HTMLDivElement>();\n\n    constructor(props: Props) {\n        super(props);\n        this.state = {\n            showAlgosMenu: false\n        }\n\n        // methods\n        this.showAlgosMenu = this.showAlgosMenu.bind(this);\n        this.closeAlgosMenu = this.closeAlgosMenu.bind(this);\n        this.displayAlgosMenu = this.displayAlgosMenu.bind(this);\n    }\n\n    showAlgosMenu(e: React.MouseEvent) {\n        // ensures that you close menu when clicked again\n        if (!this.state.showAlgosMenu){\n            this.setState({showAlgosMenu: true}, () => this.displayAlgosMenu());\n            // not sure why this works but will figure out soon\n            // makes dropdown work magically!\n            e.stopPropagation();\n            document.addEventListener(\"click\", this.closeAlgosMenu);\n        }\n    }\n\n    closeAlgosMenu() {\n        this.setState({showAlgosMenu: false}, () => this.displayAlgosMenu());\n        document.removeEventListener(\"click\", this.closeAlgosMenu)\n    }\n\n    displayAlgosMenu() {\n        if (this.state.showAlgosMenu) {\n            this.dropdownMenu.current!.style.display = \"block\";\n            this.dropdownCaret.current!.style.transform = \"rotate(180deg)\";\n            this.dropdownCaret.current!.style.transition = \"all 300ms linear\";\n        } else {\n            this.dropdownMenu.current!.style.display = \"none\";\n            this.dropdownCaret.current!.style.transform = \"rotate(0deg)\";\n            this.dropdownCaret.current!.style.transition = \"all 300ms linear\";\n        }\n    }\n\n    render() {\n        return (\n            <header id={\"header\"}>\n                <div id={\"logo-wrapper\"}>\n                    <Link to={\"/AlgoVisual\"}>\n                        <p id={\"name\"}> AlgoVisual </p>\n                    </Link>\n                </div>\n\n                <div id={\"nav-wrapper\"}>\n                    <nav id={\"nav-bar\"}>\n                        <ul>\n                            <li>\n                                <div className={\"nav-link\"}>\n                                    <div className={\"nav-option\"} onClick={this.showAlgosMenu}>\n                                        <p className={\"noselect\"}> Algorithms </p>\n                                        <i className=\"fas fa-caret-down\" ref={this.dropdownCaret}> </i>\n                                    </div>\n                                    <div id={\"dropdown\"} ref={this.dropdownMenu}>\n                                        <ul>\n                                            <li>\n                                                <Link to={\"/AlgoVisual/sorting\"} className={\"nav-link\"}>\n                                                    <div className={\"algos-option\"}>\n                                                        <p> Sorting </p>\n                                                    </div>\n                                                </Link>\n                                            </li>\n\n                                            <li>\n                                                <Link to={\"/AlgoVisual/pathfinding\"} className={\"nav-link\"}>\n                                                    <div className={\"algos-option\"}>\n                                                        <p> Pathfinding </p>\n                                                    </div>\n                                                </Link>\n                                            </li>\n\n                                            <li>\n                                                <Link to={\"/AlgoVisual/datastructures\"} className={\"nav-link\"}>\n                                                    <div className={\"algos-option\"}>\n                                                        <p> Data Structures </p>\n                                                    </div>\n                                                </Link>\n                                            </li>\n                                        </ul>\n                                    </div>\n                                </div>\n                            </li>\n\n                            <li>\n                                <Link to={\"/AlgoVisual/documentation\"} className={\"nav-link\"}>\n                                    <div className={\"nav-option\"}>\n                                        <p> Documentation </p>\n                                    </div>\n                                </Link>\n                            </li>\n\n                            <li>\n                                <Link to={\"/AlgoVisual/about\"} className={\"nav-link\"}>\n                                    <div className={\"nav-option\"}>\n                                        <p> About </p>\n                                    </div>\n                                </Link>\n                            </li>\n                        </ul>\n                    </nav>\n                </div>\n            </header>\n        )\n    }\n}\n\nexport default Header;","import React from \"react\";\nimport \"./Footer.css\";\n\ntype Props = {};\ntype State = {};\nclass Footer extends React.Component<Props, State>{\n    constructor(props:Props) {\n        super(props);\n    }\n\n    render() {\n        return (\n            <footer id=\"footer\">\n                <p id={\"footer-header\"}> Connect with me through these platforms </p>\n                <div id=\"contact-wrapper\">\n                    <ul>\n                        <li>\n                            <a href=\"https://github.com/eduardo-vidals\" target={\"_blank\"} className={\"social-link\"}>\n                                <i className={\"fab fa-github\"}> </i>\n                                <span className={\"social-text\"}> GitHub </span>\n                            </a>\n                        </li>\n\n                        <li>\n                            <a href=\"https://www.linkedin.com/in/eduardo-vidals\" target={\"blank\"} className={\"social-link\"}>\n                                <i className={\"fab fa-linkedin-in\"}> </i>\n                                <span className={\"social-text\"}> LinkedIn </span>\n                            </a>\n                        </li>\n\n                        <li>\n                            <a href=\"https://www.instagram.com/eddy_the_professionalpenguin\" target={\"blank\"} className={\"social-link\"}>\n                                <i className={\"fab fa-instagram\"}> </i>\n                                <span className={\"social-text\"}> Instagram </span>\n                            </a>\n                        </li>\n\n                        <li>\n                            <a className={\"social-link\"}>\n                                <i className={\"fab fa-discord\"}> </i>\n                                <span className={\"social-text\"}> Discord </span>\n                            </a>\n                        </li>\n\n                        <li>\n                            <a className={\"social-link\"}>\n                                <i className={\"fas fa-envelope\"}> </i>\n                                <span className={\"social-text\"}> Email </span>\n                            </a>\n                        </li>\n                    </ul>\n                </div>\n            </footer>\n        )\n    }\n}\n\nexport default Footer;","import React from \"react\";\nimport \"./Home.css\";\nimport {Link} from \"react-router-dom\"\n\ntype Props = {};\ntype State = {};\n\nclass Home extends React.Component<Props, State> {\n    constructor(props:Props) {\n        super(props);\n    }\n\n    render() {\n        return (\n            <div id={\"home-wrapper\"}>\n                <h1 id={\"home-header-text\"}> Visualizing made easy. </h1>\n                <p id={\"home-text\"}>\n                    This is my first big project, please feel free to explore the beautiful visualization\n                    of algorithms and data structures by clicking one of the buttons below.\n                </p>\n\n                <div id={\"buttons-menu\"}>\n                    <Link to={\"/AlgoVisual/sorting\"}>\n                        <div className={\"home-section\"}> Sorting Algorithms </div>\n                    </Link>\n\n                    <Link to={\"/AlgoVisual/pathfinding\"}>\n                        <div className={\"home-section\"}> Pathfinding Algorithms </div>\n                    </Link>\n\n\n                    <Link to={\"/AlgoVisual/datastructures\"}>\n                        <div className={\"home-section\"}> Data Structures </div>\n                    </Link>\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default Home;","import React from \"react\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkBreaks from \"remark-breaks\";\nimport {Prism as SyntaxHighlighter} from \"react-syntax-highlighter\";\nimport themeStyle from \"react-syntax-highlighter/dist/esm/styles/prism/nord\";\nimport ReactMarkdown from \"react-markdown\";\nimport {MathComponent} from \"mathjax-react\";\n\ntype Props = {\n    markdown: string;\n};\n\ntype State = {};\n\nlet codeStyle = {\n    padding: \"10px 30px 10px 0px\",\n    margin: 0,\n    overflow: \"auto\"\n}\n\nclass Markdown extends React.Component<Props, State> {\n    constructor(props: Props) {\n        super(props);\n    }\n\n    render() {\n        return (\n            <ReactMarkdown\n                children={this.props.markdown}\n                remarkPlugins={[[remarkGfm], [remarkBreaks]]}\n                components={{\n                    a: ({...props}) => <a target={\"_blank\"} rel={\"noreferrer\"} {...props} />,\n                    em: ({...props}) => {\n                        if (props.children[0] && typeof props.children[0] === 'string' && props.children[0].startsWith('$')) {\n                            return (<MathComponent tex={String(props.children[0].substring(1))}\n                                                   display={false}\n                                                   setting={{\"internalSpeechTitles\": true}}/>)\n\n                        }\n                        return <i {...props}/>\n                    },\n                    code({inline, className, children, ...props}) {\n                        const match = /language-(\\w+)/.exec(className || \"\");\n                        return !inline && match ? (\n                            <SyntaxHighlighter\n                                children={String(children).replace(/\\n$/, \"\")}\n                                customStyle={codeStyle}\n                                style={themeStyle}\n                                showLineNumbers={true}\n                                language={match[1]}\n                                PreTag=\"div\"\n                            />\n                        ) : (\n                            <code className={className} {...props}>\n                                {children}\n                            </code>\n                        );\n                    },\n\n                }}\n            />\n        )\n    }\n}\n\nexport default Markdown;","import React from \"react\";\nimport {introductionMarkdown} from \"../Markdown/Markdown\";\nimport Markdown from \"../../Common/Markdown\";\n\ntype Props = {\n    section: React.RefObject<HTMLDivElement>\n};\ntype State = {};\n\nclass Introduction extends React.Component<Props, State> {\n    constructor(props: Props) {\n        super(props);\n    }\n\n    componentDidMount() {\n        this.props.section.current!.style.borderLeft = \"10px white solid\";\n        this.props.section.current!.style.backgroundColor = \"#29354b\";\n    }\n\n    componentWillUnmount() {\n        if (this.props.section.current !== null) {\n            this.props.section.current.style.borderLeft = \"none\"\n            this.props.section.current.style.backgroundColor = \"inherit\";\n        }\n    }\n\n    render() {\n        return (\n            <div className={\"documentation-wrapper\"}>\n                <div className={\"documentation\"}>\n                    <div className={\"markdown\"}>\n                        <Markdown markdown={introductionMarkdown}/>\n                    </div>\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default Introduction;","export let introductionMarkdown = `\n# Introduction \nThis part of the page will go over the implementations of the algorithms and data structures that are implemented throughout the site.\n\n- Before starting, this documentation page assumes that you have a good understanding of the Java programming language. \n- An explanation of the data structures and algorithms will be provided in their respective sections. \n \n## Inspiration & Credits\n- This project was largely inspired by Clment Mihailescu's sorting and pathfinding visualizer.\n- The algorithm and data structure implementations are inspired by the Coursera algorithm courses offered by Princeton University under Robert Sedgewick & Kevin Wayne. \n- Thanks to freeCodeCamp for the wonderful projects offered within their course which helped me build a solid foundation of the React framework. \n\n## Respective Links\n- [Clment Mihailescu's Sorting Visualizer](https://github.com/clementmihailescu/Sorting-Visualizer)\n- [Clment Mihailescu's Pathfinding Visualizer](https://github.com/clementmihailescu/Pathfinding-Visualizer)\n- [Algorithms Part I by Robert Sedgewick & Kevin Wayne](https://www.coursera.org/learn/algorithms-part1)\n- [Algorithms Part II by Robert Sedgewick & Kevin Wayne](https://www.coursera.org/learn/algorithms-part2)\n- [Front End Development Libraries by freeCodeCamp](https://www.freecodecamp.org/learn/front-end-development-libraries)\n`\n\n// data structures markdown\nexport let datastructuresMarkdown = `\n# Data Structures\nThis part of the page will go over the many relevant data strucures that are implemented throughout the site. \n`\n\nexport let timeComplexityMarkdown = `\n# Time Complexity\nThis section will go over time complexity.\n\n## Brief Explanation\nTime complexity can be defined as the **asymptomatic** behavior of the graph. In simpler terms, as the size of the function gets progressively larger, we can put functions in the same asymptomatic category. For example, let's say we have the following functions: *$f(x) = 100n* and *$g(x) = n*. As *$n* gets larger, both functions become categorized under the same asymptomatic bound because the difference becomes negligible as *$n* gets larger. \n\n## Big-O Notation\nTo categorize the asymptomatic bound of an algorithm, we use Big-O notation. For example, Bubble Sort has a **worst-case** of *$O(n^2)*, which is pronounced as \"Big O of *$n^2*.\" This algorithm will be explained in the sorting section of the documentation page.  \n\n## Graph Representation\nHere is a representation of the asymptomatic bounds used when regarding data structures and algorithms. \n![Time Complexity Graph](https://he-s3.s3.amazonaws.com/media/uploads/ece920b.png)\n\n## Importance\nTime complexity is an important concept to grasp right away, as we will be analyzing the time complexity of the data structures and algorithms that will be implemented throughout the site. Click below to go to the next section. \n`\n\nexport let binarySearchTreesMarkdown = `\n# Binary Search Trees\n`\n\nexport let analysisOfDataStructuresMarkdown = `\n# Analysis of Data Structures\n`\n\nexport let arraylistMarkdown = `\n# ArrayList in Java\nThis section will go over a simple implementation of an ArrayList.\n\n## Arrays\nAs a reminder, keep in mind that arrays have a limited size in the amount of data they can hold. However, in an ArrayList we are able to manipulate arrays in such a way that allows us to insert and remove elements without having to worry about a limited size. \n\n## ArrayList Implementation\nKeeping the last section in mind, let's initialize our instance variables for our ArrayList. We will be using generics for our implementation to easily apply our ArrayList across all objects. \n\n\\`\\`\\`java\npublic class ArrayList<E> implements Iterable<E> {\n    private static final int INIT_CAPACITY = 8; // initial capacity of array\n    private E[] arr; \n    private int n; // size of array\n    \n    public ArrayList(){\n        arr = (E[]) new Object[INIT_CAPACITY]; // generic array \n        n = 0;\n    }\n}\n\\`\\`\\`\n\n### Relevant Methods\nFirst, let's implement the straightforward methods of a list.\n\\`\\`\\`java\npublic boolean isEmpty() {\n    return n == 0;\n}\n\npublic int size() {\n    return n;\n}\n\\`\\`\\`\n\n### Helper Method (Resizing Array)\nLet's now implement our first relevant helper method for an ArrayList. We will need a resize method that will use an array with a new capacity and copies all values from the old array into this new array with an updated capacity. \n\n\\`\\`\\`java\nprivate void resize(int capacity) {\n    E[] copy = (E[]) new Object[capacity];\n    for (int i = 0; i < n; i++){\n        copy[i]= arr[i];\n    }\n    arr = copy;\n}\n\\`\\`\\`\n\n### Instance Methods\nWith the help of the previous helper method, we are now able to implement our add and remove methods. \n\n\\`\\`\\`java\npublic void add(E item){\n    // resize once we reach max capacity\n    if (n == arr.length) {\n        // resizing by 2x ensures we don't resize too frequently and don't allocate too much memory\n        resize(arr.length * 2);\n    }\n    arr[n++] = item;\n}\n\npublic E remove(int index){\n    E removed = arr[index];\n    int numMoved = n - index - i; // numOfNumbers that need to be moved\n    System.arraycopy(arr, index + 1, arr, index, numMoved); // shifts elements to left by 1\n    arr[n--] = null; // decrement size and ensure last arr value is null \n    \n    // resize to ensure you don't allocate too much memory when you have a few amount of elements\n    if (n > 0 && n == arr.length / 4){\n        resize(arr.length / 2);\n    }\n    return removed;\n}\n\\`\\`\\`\n\n### Iterator\nAs a reminder, remember to implement the Iterator interface and implement the following methods: \n- hasNext()\n    - returns true or false depending on whether there is a next element\n- next()\n    - returns the next element in the iterator\n- remove()\n    - allows you to remove elements while traversing\n\nWe will implement an iterator to allow users to remove elements while the list is being traversed. Iterators also allow you to use the for-each syntax for easier traversal. \n\n\\`\\`\\`java\npublic Iterator<E> iterator() {\n    return new ListIterator();\n}\n\nprivate class ListIterator implements Iterator<E> {\n    private int i; // current index\n    \n    @Override\n    public boolean hasNext(){\n        return i < n;\n    }\n    \n    @Override\n    public E next(){\n        if (!hasNext()){\n            throw new NoSuchElementException();\n        }\n        return copy[i++];\n    }\n    \n    @Override \n    public void remove() {\n        if (i == 0) {\n            throw new IllegalStateException();\n        }\n        ArrayList.this.remove(--i);\n    }\n}\n\\`\\`\\`\n\n\n## Visualizer\n...And that's it! Our implementation of ArrayList should be working just fine. Remember, there is also a simple visualization tool of how the array operates in an ArrayList. Click the button below to check out the visualizer!\n`\n\nexport let linkedlistMarkdown = `\n# LinkedList in Java\nThis section will go over a simple implementation of ArrayList.\n\n## Objects & Classes\nThere is sometimes confusion when linked lists are introduced due to not understanding the concept of objects and classes. Therefore, it is important that you understand the idea of having a **inner** class within a class. The idea of a Linked List is that an inner class can essentially act as a *pointer* that keeps track of **previous** and **next** nodes. This idea is explained in the image below. \n\n[TO DO IMAGE]\n\n## LinkedList Implementation\nKeeping the logic of the last section in mind, we can now initialize the barebones logic of a LinkedList. We will be using generics for our implementation to easily apply our LinkedList across all objects.\n\n\\`\\`\\`java\npublic class LinkedList<E> implements Iterable<E> {\n    private Node head; // first element in list\n    private Node tail; // last element in list\n    private int n; // size of arr\n    \n    private class Node {\n        Node next; // represents the node next to this current node\n        Node prev; // represents the node prev to this current node\n        E data; // represents the data within the current node\n        \n        public Node(E data){\n            this.data = data;\n        }\n    }     \n}\n\\`\\`\\`\n\nThe code above is the barebones logic of a **doubly-linked list.** It will have **two** pointers, one pointer to the previous element and one pointer to the next element. A **singly-linked list** only has **one** pointer that points to the next element. We will be implementing a doubly-linked list as it is more efficient and it'll be easier to understand a singly-linked list after implementing a doubly-linked list.\n\n### Relevant Methods\nFirst, let's implement the straightforward methods of a list.\n\\`\\`\\`java\npublic int size(){ \n    return n;\n}\n\npublic boolean isEmpty(){\n    return n == 0;\n}\n\\`\\`\\`\n\n\n### Stacks (LIFO)\nLet's introduce the concept of a **stack** as it serves as an important concept in computer science. A **stack** data structure works as **Last In, First Out (LIFO).** An analogy for this data structure is to imagine a pile of pancakes. Which pancake is the first one to be removed? The last pancake that was put into the pile will most likely result in it being the first one removed. This concept is easily explained by the image below.\n\n[TO DO IMAGE]\n\nWe can now implement the relevant methods of a LinkedList that serve the purpose of a **stack** data structure. We will name the methods **addLast()** and **removeLast()**, but these methods can also be represented as **push()** and **pop().**\n\n\\`\\`\\`java\npublic void addLast(E data){\n    // save the \"oldTail\" in a temp variable (as this will become the old tail)\n    Node oldTail = tail;\n    // initialize new tail with new data, prev Node will always be the oldTail\n    tail = new Node(data);\n    tail.prev = oldTail;\n    // when we first add into our list, the head will be equal to the tail\n    if(isEmpty()){\n        head = tail;\n    } \n    // after that, the next value of the old tail will be the current tail\n    else {\n        oldTail.next = tail;\n    }\n    n++;\n}\n\npublic E removeLast(){\n    // throw an exception if element is being removed when list is empty\n    if (isEmpty()) {\n        throw new NoSuchElementException();\n    }  \n    // make a variable for the old tail so we can return the data when the element is removed\n    Node oldTail = tail;\n    // make new tail be equal to the prev node of the tail\n    // then make the next value null for garbage collection\n    if (size() > 1){\n        tail = tail.prev;\n        tail.next = null;  \n    }\n    // this essentially means the list is empty so make both values null\n    else {\n        head = null;\n        tail = null;\n    }\n    n--;\n    return oldTail.data;\n}\n\\`\\`\\`\n\n### Queues (LIFO)\nLet's introduce the concept of a **queue** as it serves as an important concept in computer science. A **queue** data structure works as **First In, First Out (FIFO).** An analogy for a queue is to imagine being the first person in line for Subway, eventually, you will be the first one out of line and will go about your day and enjoy your subway sandwich! This concept is easily explained by the image below. \n\n[TO DO IMAGE]\n\nWe can now implement the relevant methods of a LinkedList that serve the purpose of a **queue** data structure. We will name the methods **addFirst()** and **removeFirst()**, but these methods can also be represented as **enqueue()** and **dequeue().**\n\n\\`\\`\\`java\npublic void addFirst(E data){\n    // save the \"oldHead\" in a temp variable (as this will become the old head)\n    Node oldHead = head;\n    // initialize new head with new data, next Node will always be the oldHead\n    head = new Node(data);\n    head.next = oldHead;\n    // when we first add into our list, the tail will be equal to the head\n    if (isEmpty()){\n        tail = head;\n    } \n    // after that, the prev value of the old head will be the current head\n    else {\n        oldHead.prev = head;\n    }\n    n++;\n}\n\npublic E removeFirst(){\n    // throw an exception if element is being removed when list is empty\n    if (isEmpty()) {\n        throw new NoSuchElementException();\n    } \n    // make a variable for the old head so we can return the data when the element is removed\n    Node oldHead = head;\n    // make new head be equal to the next node of the head\n    // then make the prev value null for garbage collection\n    if (size() > 1){\n        head = head.next;\n        head.prev = null;\n    } \n    // this essentially means the list is empty so make both values null\n    else {\n        head = null;\n        tail = null;\n    }\n    n--;\n    return oldHead.data;\n}\n\\`\\`\\`\n\n### Deque\nA **deque** is simply a combination of a stack and queue data structure. As a result, our LinkedList can be defined as deque data structure as it supports the operations of a stack and queue data structure.\n\n### Iterator\nLet's now implement an iterator for our LinkedList.\n\\`\\`\\`java\npublic Iterator<E> iterator() {\n    return new LinkedIterator();\n}\n\nprivate class LinkedIterator implements Iterator<E> {\n    // keep track of current and lastAccessed nodes\n    private Node current = head;\n    private Node lastAccessed = null;\n\n    @Override\n    public boolean hasNext() {\n        return current != null;\n    }\n\n    @Override\n    public E next() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        // update lastAccessed node since it will be used to remove the lastAccessed element\n        // since the current element always updates when next() is called, thus it cannot\n        // be used within remove()\n        lastAccessed = current;\n        E data = current.data;\n        current = current.next;\n        return data;\n    }\n\n    @Override\n    public void remove() {\n        if (lastAccessed == null) {\n            throw new IllegalStateException();\n        }\n        if (lastAccessed == head) {\n            LinkedList.this.removeFirst();\n        } else if (lastAccessed == tail) {\n            LinkedList.this.removeLast();\n        } \n        // update the prev and next pointers of the lastAccessed node\n        // make the lastAccessed node null for garbage collection\n        else {\n            Node prev = lastAccessed.prev;\n            Node next = lastAccessed.next;\n            prev.next = next;\n            next.prev = prev;\n            n--;\n            lastAccessed = null;\n        }\n    }        \n}\n\\`\\`\\`\n\nThe **remove()** method might be a bit hard to understand so images will be provided for each case.\n\n[TO DO IMAGE] (removeFirst)\n[TO DO IMAGE] (removeLast)\n[TO DO IMAGE] (otherCases)\n\n## Visualizer\n...And that's it! Our implementation of a LinkedList should be working just fine. Remember, there is also a visualization tool of how the pointers operate in a LinkedList. Click the button below to check out the visualizer!\n`\n\nexport let pqMarkdown = `\n# Priority Queues\nThis section will go over **two** implementations of a priority queue.\n\n## Terminology\nThe following image will show an example of a **complete binary tree**, which is just a tree that has all levels filled except possibly the last one. In a **heap** data structure, the structure is that of a complete binary tree. To accomplish this, we use an **array** and position the elements in such a way that the element with the **highest** priority is **always** on top. A **priority queue** uses a **heap** to **add** and **remove** elements into the heap. Our implementation of a heap will start at index 1.\n![Complete Binary Tree](https://algs4.cs.princeton.edu/24pq/images/heap-representations.png)\n\n Image credits go to Robert Sedgewick & Kevin Wayne. Images can be obtained via their algorithms textbook [website.](https://algs4.cs.princeton.edu/24pq/)\n \n To move down in the tree, we use the following:\n - Node: *$k*\n - Left Child: *$2 * k*\n - Right Child: *$2 * k + 1*\n    \n To move up in the tree, we use the following:\n - Node: *$k*\n - Parent: *$k \\\\div 2*\n \n## Priority Queue Implementation\nKeeping the last section in mind, we will use a **heap** data structure to implement our priority queue such that elements with minimum values have the highest priority. We will be implementing the barebones logic of a priority queue. \n\\`\\`\\`java\n/*\n* Original authors:\n* @author Robert Sedgewick\n* @author Kevin Wayne\n*\n* Code can be obtained via their algorithms textbook website.\n* Website: https://algs4.cs.princeton.edu/24pq/\n*/\npublic class MinPQ<E> implements Iterable<E> {\n    private E[] pq; // heap data structure\n    private int n; // size of heap\n    \n    public MinPQ(int size){\n        pq = (E[]) new Object[size + 1];\n        n = 0;\n    }\n    \n    public MinPQ(){\n        this(1);\n    }\n}\n\\`\\`\\`\n\n### Relevant Methods\nFirst, let's implement the straightforward methods of our priority queue.\n\\`\\`\\`java\npublic boolean isEmpty() {\n    return n == 0;\n}\n\npublic int size() {\n    return n;\n}\n\\`\\`\\`\n\n### Helper Methods\nWe will use the following helper methods for our priority queue.\n\\`\\`\\`java\nprivate void resize(int capacity) {\n    E[] temp = (E[]) new Object[capacity];\n    for (int i = 1; i <= n; i++) {\n        temp[i] = pq[i];\n    }\n    pq = temp;\n}\n\nprivate boolean greater(int i, int j) {\n    return ((Comparable<E>) pq[i]).compareTo(pq[j]) > 0;\n}\n\nprivate void exch(int i, int j) {\n    E swap = pq[i];\n    pq[i] = pq[j];\n    pq[j] = swap;\n}\n\\`\\`\\`\n\n### Heap Helper Methods\nWe will go over two important methods regarding heaps, **swim()** and **sink().** \n\\`\\`\\`java\n// ensures the heap order is not violated when a node is greater than its parent\nprivate void swim(int k) {\n    // keep looping when a node is an index above the root\n    // and when its parent is greater in value\n    while (k > 1 && greater(k/2, k)) {\n        exch(k, k/2); // exch node with parent\n        k = k/2; // update to new node index for the loop\n    }\n}\n\n// ensures the heap order is not violated when a node is less than its children\nprivate void sink(int k) {\n    while (2*k <= n) {\n        int j = 2*k; // left child\n        // use right child if it's less than left child\n        if (j < n && greater(j, j+1)) j++;\n        // end loop if the node is less than the child\n        if (!greater(k, j)) break;\n        exch(k, j); // otherwise exchange the node and child \n        k = j; // update to new node index for the loop\n    }\n}\n\\`\\`\\`\n\n### Instance Methods\nWe can now easily implement the **insert()** and **delMin()** operations for our priority queue.\n\\`\\`\\`java\n// we insert at the end of the heap and keep our heap order by using swim()\npublic void insert(E item){\n    // double size of array if necessary\n    if (n == pq.length - 1) resize(2 * pq.length);\n    pq[++n] = item; // adds new item to heap\n    swim(n); // swim up to maintain heap order\n}\n\n// we first swap the root with the last element in the heap while also decreasing\n// the size of our heap and keep our heap order by using sink()\npublic E delMin() {\n    if (isEmpty()) throw new NoSuchElementException();\n    E min = pq[1]; // min starts at index 1\n    exch(1, n--); // swap index 1 with last element in the heap\n    sink(1); // sink down to maintain heap order\n    pq[n+1] = null; // to avoid loitering and help with garbage collection\n    // resize if size of array is too big for the number of elements it has\n    if ((n > 0) && (n == (pq.length - 1) / 4)) resize(pq.length / 2);\n    return min;\n}\n\\`\\`\\`\n\n### Iterator\nLet's now implement an iterator for our priority queue.\n\\`\\`\\`java\npublic Iterator<E> iterator() {\n    return new HeapIterator();\n}\n\nprivate class HeapIterator implements Iterator<E> {\n    // create a new pq\n    private MinPQ<E> copy;\n    // add all items to copy of heap\n    // takes linear time since already in heap order so no keys move\n    public HeapIterator() {\n        copy = new MinPQ<E>(size());\n        for (int i = 1; i <= n; i++) {\n            copy.insert(pq[i]);\n        }\n    }\n\n    public boolean hasNext() { \n        return !copy.isEmpty();            \n    }\n\n    public Key next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        return copy.delMin();\n    }\n    \n    public void remove() { \n        throw new UnsupportedOperationException();\n    }\n}\n\\`\\`\\`\n\n## Indexed Priority Queue Implementation\nThis version of a priority queue will support indexing in such a way that we can **retrieve** the values within our heap with a **unique** index key. In a way, this can be thought of as a map. This will be an important data structure when algorithms such as Prim's and Dijkstra's are introduced in the pathfinding sections of this website. We will now be implementing the barebones logic of an indexed priority queue.\n\\`\\`\\`java\n/*\n* Original authors:\n* @author Robert Sedgewick\n* @author Kevin Wayne\n*\n* Code can be obtained via their algorithms textbook website.\n* Website: https://algs4.cs.princeton.edu/24pq/\n*/\npublic class IndexMinPQ<E extends Comparable<E> implements Iterable<Integer> {\n    private int n; // size of PQ\n    private int maxN; // max size for PQ\n    private E[] keys; // keys assigned a unique index from [0, maxN)\n    private int[] pq; // gets the index a key is associated with in heap position i \n    private int[] qp; // heap position of a key with index i (inverse of pq)\n    \n    // initialize instance variables\n    public IndexMinPQ(int maxN) {\n        if (maxN < 0) throw new IllegalArgumentException();\n        this.maxN = maxN;\n        n = 0;\n        keys = (Key[]) new Comparable[maxN + 1];\n        qp   = new int[maxN + 1];\n        pq   = new int[maxN + 1];\n        // initialize arrays to -1 as there are no heap or key indexes\n        for (int i = 0; i <= maxN; i++){\n            pq[i] = -1;\n            qp[i] = -1;\n        }\n    }\n}\n\\`\\`\\`\n\n### Relevant Methods\nFirst, let's implement the straightforward methods of our priority queue.\n\\`\\`\\`java\npublic boolean isEmpty() {\n    return n == 0;\n}\n\npublic int size() {\n    return n;\n}\n\npublic boolean contains(int i) {\n    validateIndex(i);\n    return qp[i] != -1;\n}\n\\`\\`\\`\n\n\n\n### Helper Methods\nWe will define the following helper methods for our indexed priority queue.\n\\`\\`\\`java\n// used to validate the index is within the bounds [0, maxN)\nprivate void validateIndex(int i) {\n    if (i < 0) throw new IllegalArgumentException();\n    if (i >= maxN) throw new IllegalArgumentException();\n}\n\n// uses pq[i] to get key index and uses it in keys[] to get key\nprivate boolean greater(int i, int j) {\n    return keys[pq[i]].compareTo(keys[pq[j]]) > 0;\n}\n\n// exchanges values from pq (swaps key index values)\nprivate void exch(int i, int j) {\n    // swap key index values\n    int swap = pq[i];\n    pq[i] = pq[j];\n    pq[j] = swap;\n    // once we swap, update to reversed values\n    qp[pq[i]] = i;\n    qp[pq[j]] = j;\n}\n\\`\\`\\`\n\n### Heap Helper Methods\nThe **swim()** and **sink()** methods will stay the same, but it is important to notice that it uses the updated version of **exch().**\n\\`\\`\\`java\nprivate void swim(int k) {\n    while (k > 1 && greater(k/2, k)) {\n        exch(k, k/2);\n        k = k/2;\n    }\n}\n\nprivate void sink(int k) {\n    while (2*k <= n) {\n        int j = 2*k;\n        if (j < n && greater(j, j+1)) j++;\n        if (!greater(k, j)) break;\n        exch(k, j);\n        k = j;\n    }\n}\n\\`\\`\\`\n\n### Instance Methods\nWe will update our implementation of **insert()** and **deleteMin().** We will also add a new method **decreaseKey()** which will be used in several algorithms we use in future sections.\n\\`\\`\\`java\n// inserts a key with a unique index\npublic void insert(int i, Key key) {\n    validateIndex(i);\n    if (contains(i)) throw new IllegalArgumentException();\n    n++;\n    pq[n] = i; // remember, pq stores key indexes\n    qp[i] = n; // qp is the reverse\n    keys[i] = key; // store key in keys array\n    swim(n); // swim up to maintain heap order\n}\n\n// deletes min element in the PQ\npublic int delMin() {\n    if (n == 0) throw new NoSuchElementException();\n    int min = pq[1]; // min starts at index 1 (uses key index)\n    exch(1, n--); // swap index 1 with last element in the heap\n    sink(1); // sink down to maintain heap order\n    keys[min] = null; // to help with garbage collection\n    qp[min] = -1; // key index is not used, so replace heap index to -1\n    pq[n+1] = -1; // last heap index is not used, so replace key index to -1\n    return min;\n}\n\n// takes in key index and replaces it with a lower key value\npublic void decreaseKey(int i, Key key) {\n    validateIndex(i);\n    if (!contains(i)) throw new NoSuchElementException();\n    if (keys[i].compareTo(key) == 0) throw new IllegalArgumentException();\n    if (keys[i].compareTo(key) < 0) throw new IllegalArgumentException();\n    keys[i] = key; // update key to lower value\n    swim(qp[i]); // swim up to maintain heap order (qp stores heap indexes)\n}\n\\`\\`\\`\n\n### Iterator\nLet's now implement an iterator for our indexed priority queue.\n\\`\\`\\`java\npublic Iterator<Integer> iterator() { \n    return new HeapIterator();\n}\n\nprivate class HeapIterator implements Iterator<Integer> {\n    // create a new pq\n    private IndexMinPQ<Key> copy;\n\n    // add all elements to copy of heap\n    // takes linear time since already in heap order so no keys move\n    public HeapIterator() {\n        copy = new IndexMinPQ<Key>(pq.length - 1);\n        for (int i = 1; i <= n; i++) {\n            copy.insert(pq[i], keys[pq[i]]);\n        }\n    }\n\n    public boolean hasNext()  { \n        return !copy.isEmpty();        \n    }\n    \n    public Integer next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        return copy.delMin();\n    }\n    \n    public void remove() { \n        throw new UnsupportedOperationException();\n    }\n}\n\\`\\`\\`\n\n## Visualizer\n...And that's it! Our implementation of a Priority Queue & Indexed Priority Queue should be working just fine. Remember, there is also a visualization tool for visualizing a graph and digraph! Click the button below to check out the visualizer!\n`\n\n// sorting markdown\nexport let sortingMarkdown = `\n# Sorting Algorithms\nThis part of the page will go over the many relevant sorting algorithms that are implemented throughout the site. \n`\n\nexport let bubbleSortMarkdown = `\n# Bubble Sort\nThis section will go over an implementation of Bubble Sort.\n\n## Bubble Sort Implementation\nWe will be using generics for our implementation to easily apply our sorting algorithm across all types of arrays.\n\n### Rationale\nThe basis of Bubble Sort is to swap elements if the current element is greater than the element ahead.\n\n### Helper Method\nWe will be using the following **swap()** helper method to swap values from the array.\n\\`\\`\\`java\nprivate static <E> void swap(E[] arr, int i, int j){\n    E temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n\\`\\`\\`\n\n### Sorting Algorithm\nThis is the setup used for Bubble Sort.\n\n\\`\\`\\`java\n// <E extends Comparable> just means that E (the data type of the array) must\n// implement the Comparable interface, <? super E> means that E itself or the\n// super class can implement Comparable\npublic static <E extends Comparable<? super E>> void sort(E[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n        for (int j = 0; j < arr.length - 1 - i; j++) {\n            // compare elements from indices j and j + 1, swap if j > j + 1\n            if (arr[j].compareTo(arr[j + 1]) > 0){\n                swap(arr, j, j + 1);\n            }\n        }\n    }\n}\n\\`\\`\\`\n\n## Time Complexity (Analysis)\nBubble Sort is a **stable** sorting algorithm but it is often regarded as the **worst** sorting algorithm.\n- The best case can be *$O(n)*, but this implementation has a best case of *$O(n^2)*\n- The average case is *$O(n^2)*\n- The worst case is *$O(n^2)*\n\n\n## Visualizer\n...And that's it! Our implementation of Bubble Sort should be working just fine. Remember, there is also a simple visualization tool for sorting algorithms. Click the button below to check out the visualizer!\n`\n\nexport let insertionSortMarkdown = `\n# Insertion Sort\nThis section will go over an implementation of Insertion Sort.\n\n## Insertion Sort Implementation \nWe will be using generics for our implementation to easily apply our sorting algorithm across all types of arrays.\n\n### Rationale\nThe basis of Insertion Sort is to swap until there isn't an element greater than the key. This process starts with index one as the key and progressively increments until the array is fully sorted.\n\n### Sorting Algorithm\nThis is the setup used for Selection Sort.\n\\`\\`\\`java\npublic static void <E extends Comparable<? super E>> sort(E[] arr){\n    for (int i = 1; i < arr.length; i++){\n        // keep track of the key for the last swap\n        T key = arr[i];\n        // starting index will always be one below i\n        int j = i - 1;\n        // if the val to the left is bigger, then replace it\n        while(j >= 0 && arr[j].compareTo(key) > 0){\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        // we can replace arr[j + 1] with the key since that is the last swap we need to do\n        arr[j + 1] = key;\n    }\n}\n\\`\\`\\`\n\n## Time Complexity (Analysis)\nInsertion Sort is a **stable** sorting algorithm and better than Bubble Sort. However, the worst case is still *$O(n^2)*\n- The best case is *$O(n)*\n- The average case is *$O(n^2)*\n- The worst case is *$O(n^2)*\n\n## Visualizer\n...And that's it! Our implementation of Bubble Sort should be working just fine. Remember, there is also a simple visualization tool for sorting algorithms. Click the button below to check out the visualizer!\n`\n\nexport let selectionSortMarkdown = `\n# Selection Sort\nThis section will go over an implementation of Selection Sort.\n\n## Selection Sort Implementation\nWe will be using generics for our implementation to easily apply our sorting algorithm across all types of arrays.\n\n### Rationale\nThe basis of Selection Sort is to find the minimum element in the array and replace it with the current index of the outer loop. The inner loop start index increments after each iteration in the outer loop. (This allows us to ignore already sorted elements.)\n\n### Helper Method\nWe will be using the following **swap()** helper method to swap values from the array.\n\\`\\`\\`java\npublic static <E> void swap(E[] arr, int i, int j){\n    E temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n\\`\\`\\`\n\n### Sorting Algorithm\nThis is the setup used for Selection Sort. \n\n\\`\\`\\`java\npublic static <E extends Comparable<? super E> sort(E[] arr){\n    for (int i = 0; i < arr.length; i++){\n        // get min value and its index (we're only aware of 1 value so this is our min)\n        T min = arr[i];\n        int minIndex = i;\n        // start loop from i since any previous element will already be sorted\n        for (int j = i; j < arr.length; j++){\n            // if there's a new min, then update it\n            if (min.compareTo(arr[j] > 0){\n                min = arr[j];\n                minIndex = j;\n            }\n        }\n        // once you're at the end of the loop, swap the index of the smallest element with i \n        // this will put the lowest element at the start of our array\n        swap(arr, i, minIndex);\n    }\n}\n\\`\\`\\`\n\n## Time Complexity (Analysis)\nSelection Sort is an **unstable** sorting algorithm and better than Bubble Sort. However, the worst case is still *$O(n^2)*\n- The best case is *$O(n^2)*\n- The average case is *$O(n^2)*\n- The worst case is *$O(n^2)*\n\n## Visualizer\n...And that's it! Our implementation of Insertion Sort should be working just fine. Remember, there is also a simple visualization tool for sorting algorithms. Click the button below to check out the visualizer!\n`\n\nexport let mergeSortMarkdown = `\n# Merge Sort\nThis section will go over **two** versions of Merge Sort because it will show the importance in creating efficient algorithms. \n\n## Merge Sort Implementation (Version 1)\nWe will be using generics for our implementation to easily apply our sorting algorithm across all types of arrays.\n\n### Rationale\nThe basis of Merge Sort is to think of one element by itself already being **sorted**. If we have **two elements** and **merge** them, then we will have 2 elements sorted. To accomplish this we recursively call the sorting method until we only have one element. Eventually, the recursive function will be at a point where we have **two** elements. Ultimately, we use the merge function for these pair of elements and this process continues until the array is fully sorted.\n\n### Helper Method\nWe will be using the following **merge()** helper method to **merge** two arrays that are **already sorted.**\n\\`\\`\\`java\nprivate static <E extends Comparable<? super E> void merge(E[] arr, int l, int m, int r){\n    int nL = m - l + 1; // size of left aux array\n    int nR = r - m; // size of right aux array\n    \n    E[] L = (E[]) new Comparable[nL];\n    E[] R = (E[]) new Comparable[nR];\n   \n    // initialize left aux array with the values from the main array\n    for (int i = 0; i < nL; i++){\n        L[i] = arr[l + i];\n    }\n    \n    // initialize right aux array with the values from the main array\n    for (int j = 0; j < nR; j++){\n        R[j] = arr[m + j + 1];\n    }\n    \n    int i = 0; // starting index of left aux arr\n    int j = 0; // starting index of right aux arr\n    int k = l; // starting index of main arr\n    \n    while (i < nL && j < nR){\n        // compare values from both aux arrays, determine which element is lower, then update\n        // the main arr with the lowest value, then increment indices as needed\n        if (L[i].compareTo(R[j]) <= 0){\n            arr[k] = L[i++]\n        } else {\n            arr[k] = R[j++];\n        }\n        k++;\n    }\n    \n    // update main arr with remaining elements from the left aux arr\n    while (i < nL){\n        arr[k] = L[i++];\n        k++;\n    }\n    \n    // update main arr with remaining elements from the right aux arr\n    while (j < nR){\n        arr[k] = R[j++];\n        k++;\n    }\n}\n\\`\\`\\`\n\n### Sorting Algorithm\nThis is the setup used for Merge Sort. \n\n\\`\\`\\`java\npublic static <E extends Comparable<? super E> void sort(E[] arr){\n    sort(arr, 0, arr.length - 1);\n}\nprivate static <E extends Comparable<? super E> void sort(E[] arr, int l, int r){ \n    if (l < r){\n        int m = (l + r)/2; // middle index\n        sort(arr, l, m); // left side of array\n        sort(arr, m + 1, r); // right side of array\n        merge(arr, l, m, r); // merge\n    }\n}\n\\`\\`\\`\n\n### Time Complexity & Space Complexity (Analysis)\nMerge Sort is a **stable** sorting algorithm and it is the first efficient sorting algorithm that will be covered.\n- The best case is *$O(nlogn)*\n- The average case is *$O(nlogn)*\n- The worst case is *$O(nlogn)*\n\nIt also uses an **auxilary** array in **merge()**, as a result, this algorithm has a space complexity of *$O(n).*\n\n## Merge Sort Implementation (Version 2)\nThis second version of Merge Sort will be more efficient than the previous one. It will only be creating the auxilary array **once** instead of creating multiple auxilary arrays as in the previous implementation. Therefore, this version of Merge Sort is more efficient.\n\n### Sort Method\nThis will be the updated version of **sort()** that only relies on one auxilary array.\n\\`\\`\\`java\npublic static <E extends Comparable<? super E>> void sort(E[] arr) {\n    E[] aux = arr.clone();\n    sort(arr, 0, arr.length - 1, aux);\n}\nprivate static <E extends Comparable<? super E>> void sort(E[] arr, int l, int r, E[] aux) {\n    if (l < r) {\n        int m = (l + r) / 2;\n        sort(aux, l, m, arr);\n        sort(aux, m + 1, r, arr);\n        merge(arr, l, m, r, aux);\n    }\n}\n\\`\\`\\`\n\n### Merge Method\nThis will be the updated version of **merge()** that only relies on one auxilary array.\n\\`\\`\\`java\nprivate static <E extends Comparable<? super E>> void merge(E[] arr, int l, int m, int r, E[] aux) {\n    int k = l, i = l;\n    int j = m + 1;\n    while (i <= m && j <= r) {\n        if (aux[i].compareTo(aux[j]) <= 0) {\n            arr[k++] = aux[i++];\n        } else {\n            arr[k++] = aux[j++];\n        }\n    }\n    while (i <= m) {\n        arr[k++] = aux[i++];\n    }\n    while (j <= r) {\n        arr[k++] = aux[j++];\n    }\n}\n\\`\\`\\`\n\n### Time Complexity & Space Complexity (Analysis)\nThis version of Merge Sort is still a **stable** sorting algorithm.\n- The best case is *$O(nlogn)*\n- The average case is *$O(nlogn)*\n- The worst case is *$O(nlogn)*\n\nThis algorithm has a space complexity of *$O(n)*, but it is more efficient as we only clone the auxilary array once. \n\n## Visualizer\n...And that's it! Our implementation of Merge Sort should be working just fine. Remember, there is also a simple visualization tool for sorting algorithms. Click the button below to check out the visualizer!\n`\n\nexport let quickSortMarkdown = `\n# Quick Sort\nThis section will go over **two** versions of Quick Sort because it will show the importance in creating efficient algorithms.\n\n## Quick Sort Implementation (Version 1)\nWe will be using generics for our implementation to easily apply our sorting algorithm across all types of arrays.\n\n### Rationale\nThe basis of Quick Sort is to pick an element from the list and to put all elements less than the pivot to the **left** and all elements greater the pivot to the **right.** As a result, we end up finding the **pivot**, which results in that element being **sorted.** This process is known as **partitioning** and we will be implementing it as a helper method. \n\n### Helper Method \nWe will be using the following **swap()** and **partition()** helper method to find the **pivot.**\n\\`\\`\\`java\nprivate static <E extends Comparable<? super E>> int partition(E[] arr, int l, int h){\n    E pivot = arr[l]; // we will be using the lowest element given as the pivot\n    int i = l - 1; // start index\n    int j = h + 1; // end index\n    while (true){\n        // increment i every time arr[i] is less than the value of the pivot\n        do {\n            i++;\n        } while(arr[i].compareTo(pivot) < 0);\n    \n        // increment j every time arr[j] is greater than the pivot\n        do {\n            j--;\n        } while(arr[j].compareTo(pivot) > 0);\n\n        // return pivot index once i >= j\n        if (i >= j){\n            return j;\n        }\n        \n        // swap once you find a value less than pivot and a value greater than pivot\n        swap(arr, i, j);\n    }\n}\n\nprivate static <E> void swap(E[] arr, int i, int j){\n    E temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n\\`\\`\\`\n\n\n### Sorting Algorithm\nThis is the setup used for Quick Sort. \n\n\\`\\`\\`java\npublic static <E extends Comparable<? super E>> void sort(E[] arr){\n    sort(arr, 0, arr.length - 1);\n}\n\nprivate static <E extends Comparable<? super E>> void sort(E[] arr, int l, int h){\n    if (l < h){\n        int pivot = partition(arr, l, h);\n        sort(arr, l, pivot);\n        sort(arr, pivot + 1, h);\n    }\n}\n\\`\\`\\`\n\n## Time Complexity (Analysis)\nQuick Sort is an **unstable** sorting algorithm. However, the worst case is *$O(n^2)*.\n- The best case is *$O(nlogn)*\n- The average case is *$O(nlogn)*\n- The worst case is *$O(n^2)*\n\n## Quick Sort Implementation (Version 2)\nThis second version of Quick Sort will be more efficient as we will be using a **random** pivot within our partition() method. This essentially results into the worst case having an **extremely** low probability of occuring. Therefore, this version of Quick Sort is more efficient.\n\n### Sort Method\nThe sort() method will stay the same as we only have to change the pivot that is chosen.\n\n### Partition Method\nThis will be the updated version of partition() that relies on a random pivot. \n\\`\\`\\`java\nprivate static <E extends Comparable<? super E>> int partition(E[] arr, int l, int h){\n    int randomIndex = ThreadLocalRandom.current().nextInt(l, h);\n    E pivot = arr[randomIndex];\n    /* use code from previous partition() */\n}\n\\`\\`\\`\n\n### Time Complexity & Space Complexity (Analysis)\nThis version of Quick Sort is still an **unstable** sorting algorithm.\n- The best case is *$O(nlogn)*\n- The average case is *$O(nlogn)*\n- The worst case is *$O(nlogn)*\n\n## Visualizer\n...And that's it! Our implementation of Quick Sort should be working just fine. Remember, there is also a simple visualization tool for sorting algorithms. Click the button below to check out the visualizer!\n`\n\nexport let heapSortMarkdown = `\n# Heap Sort\n`\n\nexport let analysisOfSortingAlgorithmsMarkdown = `\n# Analysis of Sorting Algorithms\n`\n\nexport let pathfindingMarkdown = `\n# Pathfinding\nThis part of the page will go over the many relevant pathfinding algorithms that are implemented throughout the site.\n`\n\nexport let graphsMarkdown = `\n# Graphs\nThis part of the page will go over an implementation of an **undirected** graph and a **directed** graph.\n\n## Undirected Graphs Terminology\nThe images below explain the terminology that will be used regarding undirected graphs.\n|   |   |   |\n|:-:|:-:|:-:|\n|![Graph Anatomy](https://algs4.cs.princeton.edu/41graph/images/graph-anatomy.png)   | ![Graph Tree](https://algs4.cs.princeton.edu/41graph/images/tree.png)| ![Graph Spanning Forest](https://algs4.cs.princeton.edu/41graph/images/forest.png) |\n\n Image credits go to Robert Sedgewick & Kevin Wayne. Images can be obtained via their algorithms textbook [website.](https://algs4.cs.princeton.edu/41graph/)\n\n## Undirected Graph Implementation\nKeeping the last section in mind, we will be using adjacency-list representation for our implementation of a graph. We will be implementing the barebones logic of a graph. \n\n**NOTE**: We will also be using a **Bag** data structure, it is similar to an ArrayList, **except that it does NOT support removal of elements.**\n\\`\\`\\`java\n/*\n* Original authors:\n* @author Robert Sedgewick\n* @author Kevin Wayne\n*\n* Code can be obtained via their algorithms textbook website.\n* Website: https://algs4.cs.princeton.edu/41graph/\n*/\npublic class Graph {\n    private static final String NEWLINE = System.getProperty(\"line.separator\");\n    private final int V; // number of vertices\n    private int E; // number of edges\n    private Bag<Integer>[] adj; // adj list for vertex v\n    // initialize our instance variables\n    public Graph(int V){  \n        if (V < 0) {\n            throw new IllegalStateException();\n        }\n        this.V = V;\n        this.E = 0;\n        adj = (Bag<Integer>[]) new Bag[V]; // array of lists\n        for (int v = 0; v < V; v++){\n            adj[v] = new Bag<Integer>(); // initialize adj lists\n        }\n    }\n}\n\\`\\`\\`\n\n### Helper Method\nWe will use the following helper method to validate that our vertices are within the bounds *$[0,V - 1]*\n\\`\\`\\`java\nprivate void validateVertex(int v) {\n    if (v < 0 || v >= V){\n        throw new IllegalArgumentException();\n    }\n}\n\\`\\`\\`\n\n### Getters\nWe will be using the following methods to get the number of vertices and edges.\n\\`\\`\\`java\npublic int V(){\n    return V;\n}\n\npublic int E(){\n    return E;\n}\n\\`\\`\\`\n\n### Adding Edges\nWe will using the following method to add edges into our graph. Remember, this is an **undirected** graph, so both vertices **must** connect to one another. In a **directed** graph we would only add the edge from *$V \\\\rightarrow W*.\n\\`\\`\\`java\npublic void addEdge(int v, int w){\n    validateVertex(v);\n    validateVertex(w);\n    adj[v].add(w);\n    adj[w].add(v);\n    E++;\n}\n\\`\\`\\`\n\n### Relevant Methods\nWe will go over two important methods for graphs, **degree()** and **adj()**.\n\n### Adjacent Vertices\nWe will want to get an iterable that includes all vertices adjacent to a vertex. \n\\`\\`\\`java\npublic Iterable<Integer> adj(int v){\n    validateVertex(v);\n    return adj[v];\n}\n\\`\\`\\`\n\n### Degree\nWe will also want to know the number of vertices connected to a vertex.\n\\`\\`\\`java\npublic int degree(int v){\n    validateVertex(v);\n    return adj[v].size();\n}\n\\`\\`\\`\n\n### String Representation\nWe will use the following string representation for our graph.\n\\`\\`\\`java\npublic String toString() {\n    StringBuilder s = new StringBuilder();\n    s.append(V).append(\" vertices, \").append(E).append(\" edges \").append(NEWLINE);\n    for (int v = 0; v < V; v++) {\n        s.append(v).append(\": \");\n        for (int w : adj[v]) {\n            s.append(w).append(\" \");\n        }\n        s.append(NEWLINE);\n    }\n    return s.toString();\n}\n\\`\\`\\`\n\n## Directed Graphs Terminology\nThe images below explain the terminology that will be used regarding directed graphs.\n|   |   |   |\n|:-:|:-:|:-:|\n|![Digraph Anatomy](https://algs4.cs.princeton.edu/42digraph/images/digraph-anatomy.png)   | ![Strong Components](https://algs4.cs.princeton.edu/42digraph/images/strong-components.png)|\n\n Image credits go to Robert Sedgewick & Kevin Wayne. Images can be obtained via their algorithms textbook [website.](https://algs4.cs.princeton.edu/41graph/)\n\n## Undirected Graph Implementation\nFor the most part, an implementation of a digraph is similar to an implementation of an undirected graph, but it has a few important key differences that we will examine.\n\n**NOTE**: We will also be using a **Bag** data structure, it is similar to an ArrayList, **except that it does NOT support removal of elements.**\n\\`\\`\\`java\n/*\n* Original authors:\n* @author Robert Sedgewick\n* @author Kevin Wayne\n*\n* Code can be obtained via their algorithms textbook website.\n* Website: https://algs4.cs.princeton.edu/41graph/\n*/\n\npublic class Digraph {\n    private static final String NEWLINE = System.getProperty(\"line.separator\");\n    \n    private final int V; // number of vertices\n    private int E; // number of edges\n    private Bag<Integer>[] adj; // adj list for vertex v\n    private int[] indegree; // indegree of vertex v\n    \n    // initialize our instance variables\n    public Digraph(int V){  \n        if (V < 0) {\n            throw new IllegalStateException();\n        }\n        this.V = V;\n        this.E = 0;\n        indegree = new int[V];\n        adj = (Bag<Integer>[]) new Bag[V]; // array of lists\n        for (int v = 0; v < V; v++){\n            adj[v] = new Bag<Integer>(); // initialize adj lists\n        }\n    }\n}\n\\`\\`\\`\n\n### Helper Method\nWe will use the following helper method to validate that our vertices are within the bounds *$[0,V - 1]*\n\\`\\`\\`java\nprivate void validateVertex(int v) {\n    if (v < 0 || v >= V){\n        throw new IllegalArgumentException();\n    }\n}\n\\`\\`\\`\n\n### Getters\nWe will be using the following methods to get the number of vertices and edges.\n\\`\\`\\`java\npublic int V(){\n    return V;\n}\n\npublic int E(){\n    return E;\n}\n\\`\\`\\`\n\n### Adding Edges\nWe will using the following method to add edges into our graph. In a **directed** graph we **only** add the edge from *$V \\\\rightarrow W*. We also update the indegree value of vertex *$W*.\n\\`\\`\\`java\npublic void addEdge(int v, int w){\n    validateVertex(v);\n    validateVertex(w);\n    adj[v].add(w);\n    indegree[w]++;\n    E++;\n}\n\\`\\`\\`\n\n### Relevant Methods\nWe will go over three important methods for graphs, **indegree()**, **outdegree()**, and **adj()**.\n\n### Adjacent Vertices\nWe will want to get an iterable that includes all vertices adjacent to a vertex. \n\\`\\`\\`java\npublic Iterable<Integer> adj(int v){\n    validateVertex(v);\n    return adj[v];\n}\n\\`\\`\\`\n\n### Degree\nWe will also want to know the number of vertices connected to a vertex. For digraphs we have **outdegree** and **indegree**. Outdegree is the number of edges pointing **from** it. Indegree is the number of edges pointing **to** it.\n\\`\\`\\`java\npublic int outdegree(int v){\n    validateVertex(v);\n    return adj[v].size();\n}\n\npublic int indegree(int v){\n    validateVertex(v);\n    return indegree[v];\n}\n\\`\\`\\`\n\n### String Representation\nWe will use the following string representation for our digraph.\n\\`\\`\\`java\npublic String toString() {\n    StringBuilder s = new StringBuilder();\n    s.append(V).append(\" vertices, \").append(E).append(\" edges \").append(NEWLINE);\n    for (int v = 0; v < V; v++) {\n        s.append(v).append(\": \");\n        for (int w : adj[v]) {\n            s.append(w).append(\" \");\n        }\n        s.append(NEWLINE);\n    }\n    return s.toString();\n}\n\\`\\`\\`\n\n## Visualizer\n...And that's it! Our implementation of a Graph & Digraph should be working just fine. Remember, there is also a visualization tool for visualizing a graph and digraph! Click the button below to check out the visualizer!\n\n`\n\nexport let dfsMarkdown = `\n# Depth-First Search\nThis part of the page will go over an implementation of Depth-First Search. \n\n## Depth-First Search Implementation\nDFS will be the first searching algorithm that will be examined. This algorithm works on both **graphs** and **digraphs.** An easy explanation for this is that a graph is essentially a digraph that always has two edges within both directions. \n\n### Rationale\nDepth-First Search is a recursive algorithm that recursively visits all vertices that are adjacent to it and have not been marked. An easier way to visualize this is by using the visualizer implemented in the Pathfindings section of the website.\n\n### Helper Method\nWe will be using the following helper method to validate our vertices are within the bounds *$[0, V-1]*\n\\`\\`\\`java\nprivate void validateVertex(int v) {\n    int V = marked.length;\n    if (v < 0 || v >= V) {\n        throw new IllegalArgumentException();\n    }\n}\n\\`\\`\\`\n\n### Depth-First Search\nThis is the setup used for DFS.\n\\`\\`\\`java\n/*\n* Original authors:\n* @author Robert Sedgewick\n* @author Kevin Wayne\n*\n* Code can be obtained via their algorithms textbook website.\n* Website: https://algs4.cs.princeton.edu/41graph/\n*/\npublic class DepthFirstSearch {\n    private boolean[] marked; // marked[v] = true iff v is reachable from s\n    private int[] edgeTo; // edgeTo[v] = last edge on path from s to v\n    private final int s; // source vertex\n    \n    // initialize instance variables and do DFS\n    public DepthFirstSearch(Digraph G, int s){\n        marked = new boolean[G.V()];\n        edgeTo = new int[G.V()];\n        this.s = s;\n        validateVertex(s);\n        dfs(G, s);\n    }\n    \n    // implementation of DFS (only a few lines of code)\n    private void dfs(Digraph G, int v){\n        marked[v] = true;\n        for (int w : G.adj(v)) {\n            if (!marked[w]){\n                edgeTo[w] = v; // last vertex that vertex w came from\n                dfs(G, w); // keep on recursively calling dfs() \n            }\n        }\n    }\n}\n\\`\\`\\`\n\n### Paths\nWe will now focus on returning the path that DFS takes to go from *$S \\\\rightarrow V*. In other words, we want the path from the source to the target vertex.\n\\`\\`\\`java\n// used to determine whether there's a path from s -> v\npublic boolean hasPathTo(int v) {\n    validateVertex(v);\n    return marked[v];\n}\n\n// loop from vertex and retrace steps using edgeTo[]\n// we use a stack to return our iterable in last-first order (easy to implement)\n// ex: [1, 4, 6] would return \"6 4 1\" within our iterable\npublic Iterable<Integer> pathTo(int v) {\n    validateVertex(v);\n    if (!hasPathTo(v)) return null;\n    Stack<Integer> path = new Stack<Integer>();\n    // keep looping until edgeTo[x] returns the source vertex\n    for (int x = v; x != s; x = edgeTo[x]){\n        path.push(x);\n    }\n    // push the source once we are done looping through our edgeTo[]\n    path.push(s);\n    return path;\n}\n\\`\\`\\`\n\n## Visualizer\n...And that's it! Our implementation of a DFS should be working just fine. Remember, there is also a visualization tool for visualizing DFS! Click the button below to check out the visualizer!\n`\n\nexport let bfsMarkdown = `\n# Breadth-First Search\nThis part of the page will go over an implementation of Breadth-First Search. \n\n## Breadth-First Search Implementation\nBFS is the second searching algorithm that will be examined. This algorithm works on both **graphs** and **digraphs.** An easy explanation for this is that a graph is essentially a digraph that always has two edges within both directions. \n\n### Rationale\nBreadth-First Search is an algorithm that puts all vertices **adjacent** to the source vertex **in a queue.** Next, it uses the **first adjacent vertex** from the queue, **by removing it**, and puts all vertices adjacent to that vertex in the queue. This process continues until the queue is empty. An easier way to visualize this is by using the visualizer implemented in the Pathfindings section of the website.\n\n### Helper Method\nWe will be using the following helper method to validate our vertices are within the bounds *$[0, V-1]*\n\\`\\`\\`java\nprivate void validateVertex(int v) {\n    int V = marked.length;\n    if (v < 0 || v >= V) {\n        throw new IllegalArgumentException();\n    }\n}\n\\`\\`\\`\n\n### Breadth-First Search\nThis is the setup used for BFS.\n\\`\\`\\`java\n/*\n* Original authors:\n* @author Robert Sedgewick\n* @author Kevin Wayne\n*\n* Code can be obtained via their algorithms textbook website.\n* Website: https://algs4.cs.princeton.edu/41graph/\n*/\npublic class BreadthFirstSearch {\n    private static final int INFINITY = Integer.MAX_VALUE;\n    private boolean[] marked; // marked[v] = true iff v is reachable from s\n    private int[] edgeTo; // edgeTo[v] = last edge on path from s to v\n    private int[] distTo; // distTo[v] = length of shortest path from s to v\n    \n    // initialize instance variables and do BFS\n    public BreadthFirstSearch(Digraph G, int s){\n        marked = new boolean[G.V()];\n        edgeTo = new int[G.V()];\n        distTo = new int[G.V()];\n        for (int v = 0; v < G.V(); v++){\n            distTo[v] = INFINITY;\n        }\n        validateVertex(s);\n        bfs(G, s);\n    }\n    \n    // implementation of BFS (only a few lines of code)\n    private void bfs(Digraph G, int v){\n        Queue<Integer> q = new Queue<>();\n        marked[s] = true;\n        distTo[s] = 0; // initialize dist as 0 for source vertex\n        q.enqueue(s); // add source onto the queue\n        // keep looping until the queue is empty\n        while(!q.isEmpty()){\n            // remove element from queue\n            int v = q.dequeue();\n            // add all elements adj to the removed vertex onto the queue\n            for (int w : G.adj(v)){\n                if (!marked[w]){\n                    edgeTo[w] = v; // last vertex that vertex w came from\n                    distTo[w] = distTo[v] + 1; // update distance\n                    marked[w] = true; // mark the vertex as visited\n                    q.enqueue(w); // add vertex to the queue\n                }\n            }\n        }\n    }\n}\n\\`\\`\\`\n\n### Paths\nWe will now focus on returning the path that BFS takes to go from *$S \\\\rightarrow V*. In other words, we want the path from the source to the target vertex.\n\\`\\`\\`java\n// returns distance of path s -> v\npublic int distTo(int v){\n    validateVertex(v);\n    return distTo[v];\n}\n\n// used to determine whether there's a path from s -> v\npublic boolean hasPathTo(int v) {\n    validateVertex(v);\n    return marked[v];\n}\n\n// loop from vertex and retrace steps using edgeTo[]\n// we use a stack to return our iterable in last-first order (easy to implement)\n// ex: [1, 4, 6] would return \"6 4 1\" within our iterable\npublic Iterable<Integer> pathTo(int v) {\n    validateVertex(v);\n    if (!hasPathTo(v)) return null;\n    Stack<Integer> path = new Stack<Integer>();\n    int x; // we will need this once we are done looping to get our source vertex\n    // keep looping until distTo[x] is 0 (which means it's the source)\n    for (x = v; distTo[x] != 0; x = edgeTo[x]){\n        path.push(x);\n    }\n    // push the source once we are done looping through our edgeTo[]\n    path.push(x);\n    return path;\n}\n\\`\\`\\`\n\n## Visualizer\n...And that's it! Our implementation of a BFS should be working just fine. Remember, there is also a visualization tool for visualizing BFS! Click the button below to check out the visualizer!\n`\n\nexport let edgeWeightedGraphsMarkdown = `\n# Edge-Weighted Graphs\nThis part of the page will go over an implementation of an edge-weighted graph.\n\n## Edge-Weighted Graph Implementation\nAn edge-weighted graph is an undirected graph that has edges that either have a **weight** or **cost.** Before implementing the graph itself, we will implement the **Edge** itself.\n\n### Edge Implementation\nWe will use the following **Edge** implementation for our Edge-Weighted Graph.\n\\`\\`\\`java\n/*\n* Original authors:\n* @author Robert Sedgewick\n* @author Kevin Wayne\n*\n* Code can be obtained via their algorithms textbook website.\n* Website: https://algs4.cs.princeton.edu/41graph/\n*/\npublic class Edge implements Comparable<Edge> {\n    private final int v; // vertex v\n    private final int w; // vertex w\n    private final double weight; // weight of the edge from v -> w\n\n    // initialize instance variables\n    public Edge(int v, int w, double weight){\n        if (v < 0) throw new IllegalArgumentException();\n        if (w < 0) throw new IllegalArgumentException();\n        if (Double.isNaN(weight)) throw new IllegalArgumentException();\n        this.v = v;\n        this.w = w;\n        this.weight = weight;\n    }\n    \n    // returns weight\n    public double weight(){\n        return weight;\n    }\n    \n    // returns either vertex\n    public int either(){\n        return v;\n    }\n    \n    // returns vertex that is diff from given vertex\n    public int other(int vertex){\n        if      (vertex == v) return w;\n        else if (vertex == w) return v;\n        else throw new IllegalArgumentException();\n    }\n    \n    // used for comparing edge weights\n    @Override\n    public int compareTo(Edge that) {\n        return Double.compare(this.weight, that.weight);\n    }\n    \n    // string representation of edge\n    public String toString() {\n        return String.format(\"%d-%d %.5f\", v, w, weight);\n    }\n}\n\\`\\`\\`\n\n### Edge-Weighted Graph\nWe will be implementing the barebones logic of an Edge-Weighted Graph.\n\\`\\`\\`java\n/*\n* Original authors:\n* @author Robert Sedgewick\n* @author Kevin Wayne\n*\n* Code can be obtained via their algorithms textbook website.\n* Website: https://algs4.cs.princeton.edu/41graph/\n*/\npublic class EdgeWeightedGraph {\n    private static final String NEWLINE = System.getProperty(\"line.separator\");\n    private final int V; // number of vertices\n    private int E; // number of edges\n    private Bag<Edge>[] adj; // adj list for vertex v\n    \n    // initialize instance variables\n    public EdgeWeightedGraph(int V) {\n        if (V < 0) throw new IllegalArgumentException();\n        this.V = V;\n        this.E = 0;\n        adj = (Bag<Edge>[]) new Bag[V]; // array of lists of type edge\n        for (int v = 0; v < V; v++) {\n            adj[v] = new Bag<Edge>(); // initialize adj lists\n        }\n    }\n}\n\\`\\`\\`\n\n### Helper Method \nWe will use the following helper method to validate that our vertices are within the bounds *$[0, V-1]*\n\\`\\`\\`java\nprivate void validateVertex(int v) {\n    if (v < 0 || v >= V){\n        throw new IllegalArgumentException();\n    }\n}\n\\`\\`\\`\n\n### Getters\nWe will be using the following methods to get the number of vertices and edges.\n\\`\\`\\`java\npublic int V(){\n    return V;\n}\n\npublic int E(){\n    return E;\n}\n\\`\\`\\`\n\n### Adding Edges\nWe will using the following method to add edges into our graph. Remember, this is an **undirected** graph, so both vertices **must** connect to one another. In a **directed** graph we would only add the edge from *$V \\\\rightarrow W*\n\\`\\`\\`java\npublic void addEdge(Edge e){\n    int v = e.either();\n    int w = e.other(v);\n    validateVertex(v);\n    validateVertex(w);\n    adj[v].add(e);\n    adj[w].add(e);\n    E++;\n}\n\\`\\`\\`\n\n### Relevant Methods\nWe will go over two important methods for graphs, **degree()** and **adj()**.\n\n### Adjacent Vertices\nWe will want to get an iterable that includes all vertices adjacent to a vertex. \n\\`\\`\\`java\npublic Iterable<Integer> adj(int v){\n    validateVertex(v);\n    return adj[v];\n}\n\\`\\`\\`\n\n### Degree\nWe will also want to know the number of vertices connected to a vertex.\n\\`\\`\\`java\npublic int degree(int v){\n    validateVertex(v);\n    return adj[v].size();\n}\n\\`\\`\\`\n\n### Edges Iterable\nWe also want to be able to return all Edges within our Edge-Weighted graph.\n\\`\\`\\`java\npublic Iterable<Edge> edges() {\n    Bag<Edge> list = new Bag<Edge>();\n    for (int v = 0; v < V; v++) {\n        int selfLoops = 0;\n        for (Edge e : adj(v)) {\n            // makes sure it only adds an edge from v -> w once \n            // since one vertex will always be greater in index\n            // ex: 0 -> 1, e.other(0) = 1, so add it, e.other(1) = 0, do not add\n            // this is why the graph has an other() method\n            if (e.other(v) > v) {\n                list.add(e);\n            }\n            // handles the other case where v == w\n            // add only one copy of each self loop (self loops will be consecutive)\n            else if (e.other(v) == v) {\n                if (selfLoops % 2 == 0) list.add(e);\n                selfLoops++;\n            }\n        }\n    }\n    return list;\n}\n\\`\\`\\`\n\n### String Representation\nWe will use the following string representation for our graph.\n\\`\\`\\`java\npublic String toString() {\n    StringBuilder s = new StringBuilder();\n    s.append(V).append(\" \").append(E).append(NEWLINE);\n    for (int v = 0; v < V; v++) {\n        s.append(v).append(\": \");\n        for (Edge e : adj[v]) {\n            s.append(e).append(\"  \");\n        }\n        s.append(NEWLINE);\n    }\n    return s.toString();\n}\n## Visualizer\n...And that's it! Our implementation of an Edge-Weighted Graph should be working just fine. Remember, there is also a visualization tool for visualizing an Edge-Weighted Graph! Click the button below to check out the visualizer!\n`\n\nexport let mstsMarkdown = `\n# Minimum Spanning Trees\nThis part of the page will go over **two** implementations in finding a **minimum spanning tree.**\n\n## Terminology\nA minimum spanning tree is the spanning tree of a graph with the least amount of total weight. The image below explains this concept.\n![Minimum Spanning Trees](https://algs4.cs.princeton.edu/43mst/images/mst.png)\n\nImage credits go to Robert Sedgewick & Kevin Wayne. Images can be obtained via their algorithms textbook [website.](https://algs4.cs.princeton.edu/43mst/)\n\n## Kruskal's Algorithm Implementation\nKruskal's Algorithm will be the first algorithm we will go over as it is a simple but elegant way of finding a minimum spanning tree.\n\n### Rationale\nIn-order to find the minimum spanning tree of a graph, we have the weights in order from least to greatest by sorting the edges by weight. Start the process from least to greatest, if the edge does not make a cycle, then it is part of the minimum spanning tree. This is the basic idea of Kruskal's algorithm.\n\n### Kruskal's Algorithm\nThis is the setup used for Kruskal's Algorithm.\n\\`\\`\\`java\n/*\n* Original authors:\n* @author Robert Sedgewick\n* @author Kevin Wayne\n*\n* Code can be obtained via their algorithms textbook website.\n* Website: https://algs4.cs.princeton.edu/41graph/\n*/\n\npublic class KruskalMST {\n    private double weight;\n    private Queue<Edge> mst new Queue<>();\n    \n    public KruskalMST(EdgeWeightedGraph G){\n        // get the edges of the graph\n        Edge[] edges = new Edge(G.E());\n        int t = 0;\n        for (Edge e : G.edges()){\n            edges[t++] = e;\n        }\n        // sort edges by weight (edge uses comparable)\n        Arrays.sort(edges);\n        \n        // run greedy algorithm\n        UF uf = new UF(G.V());\n        for (int i = 0; i < G.E() && mst.size() < G.V() - 1; i++) {\n            // gets the vertices v -> w from the edge\n            Edge e = edges[i];\n            int v = e.either();\n            int w = e.other(v);\n\n            // make sure that v-w does not create a cycle\n            // in other words, make sure that both vertices aren't in the MST\n            // if both vertices aren't in the MST, add edge to MST\n            if (uf.find(v) != uf.find(w)) {\n                uf.union(v, w);     // merge v and w components\n                mst.enqueue(e);     // add edge e to mst\n                weight += e.weight();\n            }\n        }\n    }\n}\n\\`\\`\\`\n\n### Relevant Methods\nOnce we are done with the algorithm, we can get an iterable of the edges in the MST and we can get the total weigth of the MST.\n\\`\\`\\`java\npublic Iterable<Edge> edges(){\n    return  mst;\n}\n\npublic double weight(){\n    return weight;\n}\n\\`\\`\\`\n\n## Prim's Algorithm Implementation\n[TODO]\n`\n\nexport let edgeWeightedDigraphsMarkdown = `\n# Edge-Weighted Digraphs\nThis part of the page will go over an implementation of an edge-weighted digraph.\n\n## Edge-Weighted Digraph Implementation\nFor the most part, an implementation of an edge-weighted digraph is similar to an implementation of an edge-weighted graph, as it just a digraph that has edges that either have a **weight** or **cost.** Before implementing the graph itself, we will implement the DirectedEdge itself.\n\\`\\`\\`java\n/*\n* Original authors:\n* @author Robert Sedgewick\n* @author Kevin Wayne\n*\n* Code can be obtained via their algorithms textbook website.\n* Website: https://algs4.cs.princeton.edu/41graph/\n*/\npublic class DirectedEdge implements Comparable<DirectedEdge> {\n    private final int v; // vertex v\n    private final int w; // vertex w\n    private final double weight; // weight of the edge from v -> w\n\n    // initialize instance variables\n    public Edge(int v, int w, double weight){\n        if (v < 0) throw new IllegalArgumentException();\n        if (w < 0) throw new IllegalArgumentException();\n        if (Double.isNaN(weight)) throw new IllegalArgumentException();\n        this.v = v;\n        this.w = w;\n        this.weight = weight;\n    }\n    \n    // returns weight\n    public double weight(){\n        return weight;\n    }\n    \n    // returns either vertex\n    public int from(){\n        return v;\n    }\n    \n    // returns vertex that is diff from given vertex\n    public int to(int vertex){\n        return w; // key difference as we can no longer go from w -> v\n    }\n    \n    // used for comparing edge weights\n    @Override\n    public int compareTo(Edge that) {\n        return Double.compare(this.weight, that.weight);\n    }\n    \n    // string representation of edge\n    public String toString() {\n        return v + \"->\" + w + \" \" + String.format(\"%5.2f\", weight);\n    }\n}\n\\`\\`\\`\n\n### Edge-Weighted Digraph\nWe will be implementing the barebones logic of an Edge-Weighted Digraph.\n\\`\\`\\`java\n/*\n* Original authors:\n* @author Robert Sedgewick\n* @author Kevin Wayne\n*\n* Code can be obtained via their algorithms textbook website.\n* Website: https://algs4.cs.princeton.edu/41graph/\n*/\n\npublic class EdgeWeightedDigraph {\n    private static final String NEWLINE = System.getProperty(\"line.separator\");\n    private final int V; // number of vertices\n    private int E; // number of edges\n    private Bag<DirectedEdge>[] adj; // adj list for vertex v\n    private int[] indegree; // indegree of vertex v\n\n    // initialize instance variables\n    public EdgeWeightedDigraph(int V) {\n        if (V < 0) throw new IllegalArgumentException();\n        this.V = V;\n        this.E = 0;\n        this.indegree = new int[V];\n        adj = (Bag<DirectedEdge>[]) new Bag[V]; // array of lists\n        for (int v = 0; v < V; v++){\n            adj[v] = new Bag<DirectedEdge>(); // initialize adj lists\n        }\n    }\n}\n\\`\\`\\`\n\n### Helper Method \nWe will use the following helper method to validate that our vertices are within the bounds *$[0, V -1]*\n\\`\\`\\`java\nprivate void validateVertex(int v){\n    if (v < 0  || v >= V){\n        throw new IllegalArgumentException();\n    }\n}\n\\`\\`\\`\n\n### Getters \nWe will be using the following methods to get the number of vertices and edges.\n\\`\\`\\`java\npublic int V(){\n    return V;\n}\n\npublic int E(){\n    return E;\n}\n\\`\\`\\`\n\n### Adding Edges \nWe will be using the following method to add edges into our graph. In a **directed** graph we **only** add the edge from *$V \\\\rightarrow W*\n\\`\\`\\`java\npublic void addEdge(DirectedEdge e) {\n    int v = e.from();\n    int w = e.to();\n    validateVertex(v);\n    validateVertex(w);\n    adj[v].add(e);\n    indegree[w]++;\n    E++;\n}\n\\`\\`\\`\n\n### Relevant Methods\nWe will go over three important methods for graphs, **indegree()**, **outdegree()**, and **adj()**.\n\n### Adjacent Vertices\nWe will want to get an iterable that includes all vertices adjacent to a vertex.\n\\`\\`\\`java\npublic Iterable<DirectedEdge> adj(int v) {\n    validateVertex(v);\n    return adj[v];\n}\n\\`\\`\\`\n\n### Degree\nWe will also want to know the number of vertices connected to a vertex. For digraphs we have **outdegree** and **indegree**. Outdegree is the number of edges pointing **from** it. Indegree is the number of edges pointing **to** it.\n\\`\\`\\`java\npublic int outdegree(int v){\n    validateVertex(v);\n    return adj[v].size();\n}\n\npublic int indegree(int v){\n    validateVertex(v);\n    return indegree[v];\n}\n\\`\\`\\`\n\n### String Representation\nWe will use the following string representation for our digraph.\n\\`\\`\\`java\npublic String toString() {\n    StringBuilder s = new StringBuilder();\n    s.append(V).append(\" \").append(E).append(NEWLINE);\n    for (int v = 0; v < V; v++) {\n        s.append(v).append(\": \");\n        for (DirectedEdge e : adj[v]) {\n            s.append(e).append(\"  \");\n        }\n        s.append(NEWLINE);\n    }\n    return s.toString();\n}\n\\`\\`\\`\n\n## Visualizer\n...And that's it! Our implementation of an Edge-Weighted Digraph should be working just fine. Remember, there is also a visualization tool for visualizing an Edge-Weighted Digraph! Click the button below to check out the visualizer!\n`\n\nexport let shortestPathsMarkdown = `\n# Shortest Paths\nThis part of the page will over **three** implementations of finding the shortest path in an edge-weighted digraph. The **shortest path** is the path with the **least** amount of weight from the source to target vertex.\n\n## Dijkstra's Algorithm\nThe first shortest path algorithm that we will go over is Dijkstra's Algorithm. It is a famous algorithm known for finding the shortest path from a source to all other vertices. Weights **must** be non-negative in-order for Dijkstra's algorithm to find the shortest path. We will be implementing the barebones logic of the algorithm.\n\n### Helper Methods\nWe will use the following helper method to validate that our vertices are within the bounds *$[0, V - 1]*\n\\`\\`\\`java\nprivate void validateVertex(int v) {\n    if (v < 0 || v >= V){\n        throw new IllegalArgumentException();\n    }\n}\n\\`\\`\\`\n\n### Relaxation\nWe will use an idea called **relaxation** in-order to find the shortest path. The basis for relaxation is to update our data structures if we find a new shortest path from *$S \\\\rightarrow V*\n\\`\\`\\`java\n// relax edge e and update pq if changed\nprivate void relax(DirectedEdge e) {\n    int v = e.from(), w = e.to();\n    if (distTo[w] > distTo[v] + e.weight()) {\n        distTo[w] = distTo[v] + e.weight();\n        edgeTo[w] = e;\n        if (pq.contains(w)) {\n            pq.decreaseKey(w, distTo[w]);\n        } else {\n            pq.insert(w, distTo[w]);\n        }\n    }\n}\n\\`\\`\\`\n\n### Dijkstra's Algorithm\nWe can now easily implement Dijkstra's algorithm in a beautiful and concise way.\n\\`\\`\\`java\n/*\n* Original authors:\n* @author Robert Sedgewick\n* @author Kevin Wayne\n*\n* Code can be obtained via their algorithms textbook website.\n* Website: https://algs4.cs.princeton.edu/44sp/\n*/\npublic class DijkstraSP {\n    private double[] distTo;          // distTo[v] = distance  of shortest s->v path\n    private DirectedEdge[] edgeTo;    // edgeTo[v] = last edge on shortest s->v path\n    private IndexMinPQ<Double> pq;    // indexed priority queue of vertices\n    \n    // run dijkstra's algorithm\n    public DijkstraSP(EdgeWeightedDigraph G, int s){\n        for (DirectedEdge e : G.edges()) {\n            if (e.weight() < 0){\n                throw new IllegalArgumentException();\n            }\n        }\n        distTo = new double[G.V()];\n        edgeTo = new DirectedEdge[G.V()];\n        // validate that the source vertex exists\n        validateVertex(s);\n        // make all weights as infinity\n        for (int v = 0; v < G.V(); v++) {\n            distTo[v] = Double.POSITIVE_INFINITY;\n        }\n        // except for the vertex, as that is our starting vertex\n        distTo[s] = 0.0;\n        // relax vertices in order of distance from s\n        pq = new IndexMinPQ<Double>(G.V());\n        pq.insert(s, distTo[s]);\n        while (!pq.isEmpty()) {\n            int v = pq.delMin();\n            for (DirectedEdge e : G.adj(v)){\n                relax(e);\n            }\n        }\n    }\n}\n\\`\\`\\`\n\n### Paths\nWe will now focus on returning the path that BFS takes to go from *$S \\\\rightarrow V*. In other words, we want the path from the source to the target vertex.\n\\`\\`\\`java\n// returns distance of path s -> v\npublic double distTo(int v) {\n    validateVertex(v);\n    return distTo[v];\n}\n\n// used to determine whether there's a path from s -> v\npublic boolean hasPathTo(int v) {\n    validateVertex(v);\n    return distTo[v] < Double.POSITIVE_INFINITY;\n}\n    \n// loop from vertex and retrace steps using edgeTo[]\n// we use a stack to return our iterable in last-first order (easy to implement)\n// ex: [1, 4, 6] would return \"6 4 1\" within our iterable\npublic Iterable<DirectedEdge> pathTo(int v) {\n    validateVertex(v);\n    if (!hasPathTo(v)) return null;\n    Stack<DirectedEdge> path = new Stack<DirectedEdge>();\n    for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {\n        path.push(e);\n    }\n    return path;\n}\n\\`\\`\\`\n\n### Visualizer\n...And that's it! Our implementation of a Dijkstra's Algorithm should be working just fine. Remember, there is also a visualization tool for visualizing BFS! Click the button below to check out the visualizer!\n`\n\nexport let maxFlowMinCutMarkdown = `\n# Maxflow-Mincut\n\n`\n","import React from \"react\";\nimport {Link} from \"react-router-dom\";\nimport \"./Sections.css\"\n\ntype Props = | {\n    sections: string[],\n    directory: string,\n    sectionHighlight: false,\n    wrapperStyle?: any\n} | {\n    sections: string[],\n    directory: string,\n    sectionHighlight: true,\n    section: number,\n    wrapperStyle?: any\n};\n\ntype State = {};\n\nconst textDecoration = {\n    textDecoration: \"none\"\n}\n\nconst listStyle = {\n    listStyleType: \"none\",\n    padding: \"10px\",\n    margin: \"10px 0\",\n    fontSize: \"15px\",\n    borderRadius: \"10px\",\n    cursor: \"pointer\",\n    color: \"black\"\n}\n\nconst listBreakStyle = {\n    margin: \"0 13px\",\n    height: \"1px\",\n    backgroundColor: \"#c5c5c5\",\n    border: \"none\",\n    borderRadius: \"5px\"\n}\n\nclass Sections extends React.Component<Props, State> {\n    constructor(props: Props) {\n        super(props);\n    }\n\n    // turns pascal/snake case into dash seperated words (for links)\n    linkify(text: string) {\n        return text\n            .replace(/ *\\([^)]*\\) */g, \"\") // remove parantheses and contents\n            .replace(/[^a-zA-Z0-9]+/g, '-')\n            .replace(/([A-Z]+)([A-Z][a-z])/g, '$1-$2')\n            .replace(/([a-z])([A-Z])/g, '$1-$2')\n            .replace(/([0-9])([^0-9])/g, '$1-$2')\n            .replace(/([^0-9])([0-9])/g, '$1-$2')\n            .replace(/-+/g, '-')\n            .toLowerCase();\n    }\n\n    render() {\n        let sections = this.props.sections.map((section, index) => (\n            <div>\n                <Link to={this.props.directory + \"/\" + this.linkify(section)} style={textDecoration}>\n                    {this.props.sectionHighlight && index === this.props.section - 1 ?\n                        <li key={section} style={listStyle} className={\"active-section\"}> {++index}. {section}</li> :\n                        <li key={section} style={listStyle}> {++index}. {section}</li>}\n                </Link>\n                {index < this.props.sections.length ? <hr style={listBreakStyle}/> : null}\n            </div>\n        ));\n\n        return (\n            <div className={\"sections-wrapper-wrapper\"}>\n                <div className={\"sections-wrapper\"} style={this.props.wrapperStyle}>\n                    <div className={\"sections\"}>\n                        <p className={\"sections-header\"}> In this part: </p>\n                        <div className={\"section-names\"}>\n                            <ul>\n                                {sections}\n                            </ul>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default Sections;","import React from \"react\";\nimport {datastructuresMarkdown} from \"../Markdown/Markdown\";\nimport Sections from \"../../Common/Sections\";\nimport Markdown from \"../../Common/Markdown\";\n\n\ntype Props = {\n    section: React.RefObject<HTMLDivElement>\n};\ntype State = {};\n\nconst sections = [\"Time Complexity\", \"ArrayList\", \"LinkedList\", \"Priority Queues\", \"Binary Search Trees\", \"Analysis of Data Structures\"];\n\nlet wrapperStyle = {\n    width: \"100%\"\n}\n\nclass DataStructures extends React.Component<Props, State> {\n    constructor(props: Props) {\n        super(props);\n    }\n\n    componentDidMount() {\n        this.props.section.current!.style.borderLeft = \"10px white solid\";\n        this.props.section.current!.style.backgroundColor = \"#29354b\";\n    }\n\n    componentWillUnmount() {\n        if (this.props.section.current !== null) {\n            this.props.section.current.style.borderLeft = \"none\"\n            this.props.section.current.style.backgroundColor = \"inherit\";\n        }\n    }\n\n    render() {\n        return (\n            <div className={\"documentation-wrapper\"}>\n                <div className={\"documentation\"}>\n                    <div className={\"markdown\"}>\n                        <Markdown markdown={datastructuresMarkdown}/>\n                    </div>\n                    <Sections wrapperStyle={wrapperStyle} sectionHighlight={false} sections={sections}\n                              directory={\"/AlgoVisual/documentation/data-structures\"}/>\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default DataStructures;","import React from \"react\";\nimport {sortingMarkdown} from \"../Markdown/Markdown\";\nimport Markdown from \"../../Common/Markdown\";\nimport Sections from \"../../Common/Sections\";\n\ntype Props = {\n    section: React.RefObject<HTMLDivElement>\n};\ntype State = {};\n\nconst sections = [\"Bubble Sort\", \"Insertion Sort\", \"Selection Sort\", \"Merge Sort\", \"Quick Sort\", \"Heap Sort\", \"Analysis of Sorting Algorithms\"]\nlet wrapperStyle = {\n    width: \"100%\"\n}\n\nclass Sorting extends React.Component<Props, State> {\n    constructor(props: Props) {\n        super(props);\n    }\n\n    componentDidMount() {\n        this.props.section.current!.style.borderLeft = \"10px white solid\";\n        this.props.section.current!.style.backgroundColor = \"#29354b\";\n    }\n\n    componentWillUnmount() {\n        if (this.props.section.current !== null) {\n            this.props.section.current.style.borderLeft = \"none\"\n            this.props.section.current.style.backgroundColor = \"inherit\";\n        }\n    }\n\n    render() {\n        return (\n            <div className={\"documentation-wrapper\"}>\n                <div className={\"documentation\"}>\n                    <div className={\"markdown\"}>\n                        <Markdown markdown={sortingMarkdown}/>\n                    </div>\n                    <Sections wrapperStyle={wrapperStyle} sections={sections}\n                              directory={\"/AlgoVisual/documentation/sorting\"} sectionHighlight={false}/>\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default Sorting;","import React from \"react\";\nimport Markdown from \"../../Common/Markdown\";\nimport {pathfindingMarkdown} from \"../Markdown/Markdown\";\nimport Sections from \"../../Common/Sections\";\n\ntype Props = {\n    section: React.RefObject<HTMLDivElement>\n};\ntype State = {};\n\nconst sections = [\"Graphs\", \"Depth-First Search (DFS)\", \"Breadth-First Search (BFS)\", \"Edge-Weighted Graphs\",\n    \"Minimum Spanning Trees (MSTs)\", \"Edge-Weighted Digraphs\",\"Shortest Paths\", \"Maxflow-Mincut\"];\n\nlet wrapperStyle = {\n    width: \"100%\"\n}\n\nclass Pathfinding extends React.Component<Props, State> {\n    constructor(props: Props) {\n        super(props);\n    }\n\n    componentDidMount() {\n        this.props.section.current!.style.borderLeft = \"10px white solid\";\n        this.props.section.current!.style.backgroundColor = \"#29354b\";\n    }\n\n    componentWillUnmount() {\n        if (this.props.section.current !== null) {\n            this.props.section.current.style.borderLeft = \"none\"\n            this.props.section.current.style.backgroundColor = \"inherit\";\n        }\n    }\n\n    render() {\n        return (\n            <div className={\"documentation-wrapper\"}>\n                <div className={\"documentation\"}>\n                    <div className={\"markdown\"}>\n                        <Markdown markdown={pathfindingMarkdown}/>\n                    </div>\n                    <Sections wrapperStyle={wrapperStyle} sectionHighlight={false} sections={sections}\n                              directory={\"/AlgoVisual/documentation/pathfinding\"}/>\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default Pathfinding;","import { useEffect } from 'react';\nimport { withRouter } from 'react-router-dom';\n\nfunction ScrollToTopNewPage({ history }) {\n    useEffect(() => {\n        const unlisten = history.listen(() => {\n            window.scrollTo(0, 0);\n        });\n        return () => {\n            unlisten();\n        }\n    }, []);\n\n    return null;\n}\n\nexport default withRouter(ScrollToTopNewPage);","import React from \"react\";\nimport {Link} from \"react-router-dom\";\nimport \"./NextSection.css\";\n\ntype Props = {\n    directory: string\n    sectionName: string\n};\ntype State = {};\n\nconst endSectionStyle = {\n    marginTop: \"20px\"\n}\n\nconst nextSectionStyle = {\n    margin: \"15px 0\",\n    display: \"flex\",\n    padding: \"10px 5px\",\n    borderRadius: \"5px\",\n    color: \"black\"\n}\n\nconst nextSectionTextStyle = {\n    marginLeft: \"10px\",\n    fontSize: \"15px\"\n}\n\nconst textDecoration = {\n    textDecoration: \"none\"\n}\n\nclass NextSection extends React.Component<Props, State> {\n    constructor(props: Props) {\n        super(props);\n    }\n\n    render() {\n        return (\n            <div className={\"next-section-wrapper\"}>\n                <p style={endSectionStyle}> You have reached the end of this section! Continue to the next section: </p>\n                <Link to={this.props.directory} style={textDecoration}>\n                    <div className={\"next-section\"} style={nextSectionStyle}>\n                        <i className=\"fas fa-arrow-right\"/>\n                        <p style={nextSectionTextStyle}> {this.props.sectionName} </p>\n                    </div>\n                </Link>\n            </div>\n        )\n    }\n}\n\nexport default NextSection;","import React from \"react\";\nimport Markdown from \"./Markdown\";\nimport NextSection from \"./NextSection\";\nimport Sections from \"./Sections\";\n\ntype Props = | {\n    markdown: string,\n    nextSection: false,\n    section: React.RefObject<HTMLDivElement>,\n    partNumber: number,\n    sections: string[],\n    mainDirectory: string\n}\n    | {\n    markdown: string,\n    nextSection: true,\n    nextSectionDirectory: string,\n    nextSectionName: string,\n    section: React.RefObject<HTMLDivElement>,\n    partNumber: number,\n    sections: string[],\n    mainDirectory: string\n};\ntype State = {};\nconst endSectionStyle = {\n    margin: \"20px 0\"\n}\n\nlet wrapperStyle = {\n    width: \"60%\"\n}\n\nclass MarkdownPage extends React.Component<Props, State> {\n    constructor(props: Props) {\n        super(props);\n    }\n\n    componentDidMount() {\n        this.props.section.current!.style.borderLeft = \"10px white solid\";\n        this.props.section.current!.style.backgroundColor = \"#29354b\";\n    }\n\n    componentWillUnmount() {\n        if (this.props.section.current !== null) {\n            this.props.section.current.style.borderLeft = \"none\"\n            this.props.section.current.style.backgroundColor = \"inherit\";\n        }\n    }\n\n    render() {\n        return (\n            <div className={\"documentation-wrapper\"}>\n                <div className={\"documentation\"}>\n                    <div className={\"markdown\"}>\n                        <Markdown markdown={this.props.markdown}/>\n                    </div>\n                    {this.props.nextSection ? <NextSection directory={this.props.nextSectionDirectory}\n                                                           sectionName={this.props.nextSectionName}/> :\n                        <p style={endSectionStyle}> You have reached the end of the section!</p>}\n                    <Sections wrapperStyle={wrapperStyle} sections={this.props.sections} directory={this.props.mainDirectory} sectionHighlight={true}\n                              section={this.props.partNumber}/>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default MarkdownPage;\n","import React from \"react\";\nimport \"./ScrollToTopButton.css\";\n\ntype Props = {};\ntype State = {\n    isVisible: boolean\n};\n\nclass ScrollToTopButton extends React.Component<Props, State>{\n    constructor(props:Props) {\n        super(props);\n        this.state = {\n            isVisible: false\n        };\n    }\n\n    componentDidMount() {\n        const scrollComponent = this;\n        document.addEventListener(\"scroll\", () => {\n            scrollComponent.toggleVisibility();\n        });\n    }\n\n    toggleVisibility() {\n        if (window.scrollY > 100) {\n            this.setState({\n                isVisible: true\n            });\n        } else {\n            this.setState({\n                isVisible: false\n            });\n        }\n    }\n\n    scrollToTop() {\n        window.scrollTo({\n            top: 0,\n            behavior: \"smooth\"\n        });\n    }\n\n    render() {\n        return (\n            <div className={\"scroll-to-top-button\"}>\n                {this.state.isVisible && (\n                    <div onClick={() => this.scrollToTop()}>\n                        <div className={\"scroll-up\"}>\n                            <i className=\"fas fa-angle-up\"/>\n                        </div>\n                    </div>\n                )}\n            </div>\n        );\n    }\n}\n\nexport default ScrollToTopButton;","import React, {createRef} from \"react\";\nimport \"./Documentation.css\";\nimport {Link, Route, Switch} from \"react-router-dom\";\nimport Introduction from \"../Sections/Introduction/Introduction\";\nimport DataStructures from \"../Sections/DataStructures/DataStructures\";\nimport Sorting from \"../Sections/Sorting/Sorting\";\nimport Pathfinding from \"../Sections/Pathfinding/Pathfinding\";\nimport * as pageMarkdown from \"../Sections/Markdown/Markdown\";\nimport ScrollToTopNewPage from \"../Common/ScrollToTopNewPage\";\nimport MarkdownPage from \"../Common/MarkdownPage\";\nimport \"../Sections/Markdown/Markdown.css\";\nimport ScrollToTopButton from \"../Common/ScrollToTopButton\";\n\ntype Props = {};\ntype State = {\n    hover: false,\n};\n\nconst dataStructuresSections = [\"Time Complexity\", \"ArrayList\", \"LinkedList\", \"Priority Queue\", \"Binary Search Trees\", \"Analysis of Data Structures\"];\nconst sortingSections = [\"Bubble Sort\", \"Insertion Sort\", \"Selection Sort\", \"Merge Sort\", \"Quick Sort\", \"Heap Sort\", \"Analysis of Sorting Algorithms\"]\nconst pathfindingSections = [\"Graphs\", \"Depth-First Search (DFS)\", \"Breadth-First Search (BFS)\", \"Edge-Weighted Graphs\",\n    \"Minimum Spanning Trees (MSTs)\", \"Edge-Weighted Digraphs\", \"Shortest Paths\", \"Maxflow-Mincut\"];\n\nclass Documentation extends React.Component {\n    private gettingStartedSection = createRef<HTMLDivElement>();\n    private dataStructuresSection = createRef<HTMLDivElement>();\n    private sortingSection = createRef<HTMLDivElement>();\n    private pathfindingSection = createRef<HTMLDivElement>();\n\n    constructor(props: Props) {\n        super(props);\n    }\n\n    render() {\n        return (\n            <main className={\"main-sidebar\"}>\n                <div className={\"sidebar\"}>\n                    <div id={\"documentation-section\"}>\n                        <Link to={\"/AlgoVisual/documentation\"} className={\"documentation-link\"}>\n                            <div className={\"section\"} ref={this.gettingStartedSection}>\n                                <p> Introduction </p>\n                            </div>\n                        </Link>\n\n                        <Link to={\"/AlgoVisual/documentation/data-structures\"} className={\"documentation-link\"}>\n                            <div className={\"section\"} ref={this.dataStructuresSection}>\n                                <p> Data Structures </p>\n                            </div>\n                        </Link>\n\n                        <Link to={\"/AlgoVisual/documentation/sorting\"} className={\"documentation-link\"}>\n                            <div className={\"section\"} ref={this.sortingSection}>\n                                <p> Sorting </p>\n                            </div>\n                        </Link>\n\n                        <Link to={\"/AlgoVisual/documentation/pathfinding\"} className={\"documentation-link\"}>\n                            <div className={\"section\"} ref={this.pathfindingSection}>\n                                <p> Pathfinding </p>\n                            </div>\n                        </Link>\n                    </div>\n                </div>\n\n                { /* scrolls to top of page */}\n                <ScrollToTopNewPage/>\n                <Switch>\n                    {/* main documentation page */}\n                    <Route exact path={\"/AlgoVisual/documentation\"}>\n                        <Introduction section={this.gettingStartedSection}/>\n                    </Route>\n\n                    {/* data structures and sections */}\n                    <Route exact path={\"/AlgoVisual/documentation/data-structures\"}>\n                        <DataStructures section={this.dataStructuresSection}/>\n                    </Route>\n\n                    <Route exact path={\"/AlgoVisual/documentation/data-structures/time-complexity\"}>\n                        <MarkdownPage mainDirectory={\"/AlgoVisual/documentation/data-structures\"}\n                                      sections={dataStructuresSections} partNumber={1}\n                                      markdown={pageMarkdown.timeComplexityMarkdown}\n                                      section={this.dataStructuresSection}\n                                      nextSectionDirectory={\"/AlgoVisual/documentation/data-structures/array-list\"}\n                                      nextSection={true} nextSectionName={\"2. ArrayList\"}/>\n                    </Route>\n\n                    <Route exact path={\"/AlgoVisual/documentation/data-structures/array-list\"}>\n                        <MarkdownPage mainDirectory={\"/AlgoVisual/documentation/data-structures\"}\n                                      sections={dataStructuresSections} partNumber={2}\n                                      markdown={pageMarkdown.arraylistMarkdown} section={this.dataStructuresSection}\n                                      nextSectionDirectory={\"/AlgoVisual/documentation/data-structures/linked-list\"}\n                                      nextSection={true} nextSectionName={\"3. LinkedList\"}/>\n                    </Route>\n\n                    <Route exact path={\"/AlgoVisual/documentation/data-structures/linked-list\"}>\n                        <MarkdownPage mainDirectory={\"/AlgoVisual/documentation/data-structures\"}\n                                      sections={dataStructuresSections} partNumber={3}\n                                      markdown={pageMarkdown.linkedlistMarkdown} section={this.dataStructuresSection}\n                                      nextSectionDirectory={\"/AlgoVisual/documentation/data-structures/priority-queues\"}\n                                      nextSection={true} nextSectionName={\"4. Priority Queues\"}/>\n                    </Route>\n\n                    <Route exact path={\"/AlgoVisual/documentation/data-structures/priority-queues\"}>\n                        <MarkdownPage mainDirectory={\"/AlgoVisual/documentation/data-structures\"}\n                                      sections={dataStructuresSections} partNumber={4}\n                                      markdown={pageMarkdown.pqMarkdown} section={this.dataStructuresSection}\n                                      nextSectionDirectory={\"/AlgoVisual/documentation/data-structures/binary-search-trees\"}\n                                      nextSection={true} nextSectionName={\"5. Binary Search Trees\"}/>\n                    </Route>\n\n                    <Route exact path={\"/AlgoVisual/documentation/data-structures/binary-search-trees\"}>\n                        <MarkdownPage mainDirectory={\"/AlgoVisual/documentation/data-structures\"}\n                                      sections={dataStructuresSections} partNumber={5}\n                                      markdown={pageMarkdown.binarySearchTreesMarkdown}\n                                      section={this.dataStructuresSection}\n                                      nextSectionDirectory={\"/AlgoVisual/documentation/data-structures/analysis-of-data-structures\"}\n                                      nextSection={true} nextSectionName={\"6. Analysis of Data Structures\"}/>\n                    </Route>\n\n                    <Route exact path={\"/AlgoVisual/documentation/data-structures/analysis-of-data-structures\"}>\n                        <MarkdownPage mainDirectory={\"/AlgoVisual/documentation/data-structures\"}\n                                      sections={dataStructuresSections} partNumber={6}\n                                      markdown={pageMarkdown.analysisOfDataStructuresMarkdown}\n                                      section={this.dataStructuresSection}\n                                      nextSection={false}/>\n                    </Route>\n\n                    {/* sorting and sections */}\n                    <Route exact path={\"/AlgoVisual/documentation/sorting\"}>\n                        <Sorting section={this.sortingSection}/>\n                    </Route>\n\n                    <Route exact path={\"/AlgoVisual/documentation/sorting/bubble-sort\"}>\n                        <MarkdownPage mainDirectory={\"/AlgoVisual/documentation/sorting\"} sections={sortingSections}\n                                      partNumber={1} markdown={pageMarkdown.bubbleSortMarkdown}\n                                      section={this.sortingSection}\n                                      nextSectionDirectory={\"/AlgoVisual/documentation/sorting/insertion-sort\"}\n                                      nextSection={true} nextSectionName={\"2. Insertion Sort\"}/>\n                    </Route>\n\n                    <Route exact path={\"/AlgoVisual/documentation/sorting/insertion-sort\"}>\n                        <MarkdownPage mainDirectory={\"/AlgoVisual/documentation/sorting\"} sections={sortingSections}\n                                      partNumber={2} markdown={pageMarkdown.insertionSortMarkdown}\n                                      section={this.sortingSection}\n                                      nextSectionDirectory={\"/AlgoVisual/documentation/sorting/selection-sort\"}\n                                      nextSection={true} nextSectionName={\"3. Selection Sort\"}/>\n                    </Route>\n\n                    <Route exact path={\"/AlgoVisual/documentation/sorting/selection-sort\"}>\n                        <MarkdownPage mainDirectory={\"/AlgoVisual/documentation/sorting\"} sections={sortingSections}\n                                      partNumber={3} markdown={pageMarkdown.selectionSortMarkdown}\n                                      section={this.sortingSection}\n                                      nextSectionDirectory={\"/AlgoVisual/documentation/sorting/merge-sort\"}\n                                      nextSection={true} nextSectionName={\"4. Merge Sort\"}/>\n                    </Route>\n\n                    <Route exact path={\"/AlgoVisual/documentation/sorting/merge-sort\"}>\n                        <MarkdownPage mainDirectory={\"/AlgoVisual/documentation/sorting\"} sections={sortingSections}\n                                      partNumber={4} markdown={pageMarkdown.mergeSortMarkdown}\n                                      section={this.sortingSection}\n                                      nextSectionDirectory={\"/AlgoVisual/documentation/sorting/quick-sort\"}\n                                      nextSection={true} nextSectionName={\"5. Quick Sort\"}/>\n                    </Route>\n\n                    <Route exact path={\"/AlgoVisual/documentation/sorting/quick-sort\"}>\n                        <MarkdownPage mainDirectory={\"/AlgoVisual/documentation/sorting\"} sections={sortingSections}\n                                      partNumber={5} markdown={pageMarkdown.quickSortMarkdown}\n                                      section={this.sortingSection}\n                                      nextSectionDirectory={\"/AlgoVisual/documentation/sorting/heap-sort\"}\n                                      nextSection={true} nextSectionName={\"6. Heap Sort\"}/>\n                    </Route>\n\n                    <Route exact path={\"/AlgoVisual/documentation/sorting/heap-sort\"}>\n                        <MarkdownPage mainDirectory={\"/AlgoVisual/documentation/sorting\"} sections={sortingSections}\n                                      partNumber={6} markdown={pageMarkdown.heapSortMarkdown}\n                                      section={this.sortingSection}\n                                      nextSectionDirectory={\"/AlgoVisual/documentation/sorting/analysis-of-sorting-algorithms\"}\n                                      nextSection={true} nextSectionName={\"7. Analysis of Sorting Algorithms\"}/>\n                    </Route>\n\n                    <Route exact path={\"/AlgoVisual/documentation/sorting/analysis-of-sorting-algorithms\"}>\n                        <MarkdownPage mainDirectory={\"/AlgoVisual/documentation/sorting\"} sections={sortingSections}\n                                      partNumber={7} markdown={pageMarkdown.analysisOfSortingAlgorithmsMarkdown}\n                                      section={this.sortingSection}\n                                      nextSection={false}/>\n                    </Route>\n\n                    {/* pathfinding and sections */}\n                    <Route exact path={\"/AlgoVisual/documentation/pathfinding\"}>\n                        <Pathfinding section={this.pathfindingSection}/>\n                    </Route>\n\n                    <Route exact path={\"/AlgoVisual/documentation/pathfinding/graphs\"}>\n                        <MarkdownPage mainDirectory={\"/AlgoVisual/documentation/pathfinding\"}\n                                      sections={pathfindingSections} partNumber={1}\n                                      markdown={pageMarkdown.graphsMarkdown} section={this.pathfindingSection}\n                                      nextSection={true} nextSectionName={\"2. Depth-First Search (DFS)\"}\n                                      nextSectionDirectory={\"/AlgoVisual/documentation/pathfinding/depth-first-search\"}/>\n\n                    </Route>\n\n                    <Route exact path={\"/AlgoVisual/documentation/pathfinding/depth-first-search\"}>\n                        <MarkdownPage mainDirectory={\"/AlgoVisual/documentation/pathfinding\"}\n                                      sections={pathfindingSections} partNumber={2}\n                                      markdown={pageMarkdown.dfsMarkdown} section={this.pathfindingSection}\n                                      nextSection={true} nextSectionName={\"3. Breadth-First Search (BFS)\"}\n                                      nextSectionDirectory={\"/AlgoVisual/documentation/pathfinding/breadth-first-search\"}/>\n                    </Route>\n\n                    <Route exact path={\"/AlgoVisual/documentation/pathfinding/breadth-first-search\"}>\n                        <MarkdownPage mainDirectory={\"/AlgoVisual/documentation/pathfinding\"}\n                                      sections={pathfindingSections} partNumber={3}\n                                      markdown={pageMarkdown.bfsMarkdown} section={this.pathfindingSection}\n                                      nextSection={true} nextSectionName={\"4. Edge-Weighted Graphs\"}\n                                      nextSectionDirectory={\"/AlgoVisual/documentation/pathfinding/edge-weighted-graphs\"}/>\n                    </Route>\n\n                    <Route exact path={\"/AlgoVisual/documentation/pathfinding/edge-weighted-graphs\"}>\n                        <MarkdownPage mainDirectory={\"/AlgoVisual/documentation/pathfinding\"}\n                                      sections={pathfindingSections} partNumber={4}\n                                      markdown={pageMarkdown.edgeWeightedGraphsMarkdown} section={this.pathfindingSection}\n                                      nextSection={true} nextSectionName={\"5. Minimum Spanning Trees\"}\n                                      nextSectionDirectory={\"/AlgoVisual/documentation/pathfinding/minimum-spanning-trees\"}/>\n                    </Route>\n\n                    <Route exact path={\"/AlgoVisual/documentation/pathfinding/minimum-spanning-trees\"}>\n                        <MarkdownPage mainDirectory={\"/AlgoVisual/documentation/pathfinding\"}\n                                      sections={pathfindingSections} partNumber={5}\n                                      markdown={pageMarkdown.mstsMarkdown} section={this.pathfindingSection}\n                                      nextSection={true} nextSectionName={\"6. Edge-Weighted Digraphs\"}\n                                      nextSectionDirectory={\"/AlgoVisual/documentation/pathfinding/edge-weighted-digraphs\"}/>\n                    </Route>\n\n                    <Route exact path={\"/AlgoVisual/documentation/pathfinding/edge-weighted-digraphs\"}>\n                        <MarkdownPage mainDirectory={\"/AlgoVisual/documentation/pathfinding\"}\n                                      sections={pathfindingSections} partNumber={6}\n                                      markdown={pageMarkdown.edgeWeightedDigraphsMarkdown} section={this.pathfindingSection}\n                                      nextSection={true} nextSectionName={\"7. Shortest Paths\"}\n                                      nextSectionDirectory={\"/AlgoVisual/documentation/pathfinding/shortest-paths\"}/>\n                    </Route>\n\n                    <Route exact path={\"/AlgoVisual/documentation/pathfinding/shortest-paths\"}>\n                        <MarkdownPage mainDirectory={\"/AlgoVisual/documentation/pathfinding\"}\n                                      sections={pathfindingSections} partNumber={7}\n                                      markdown={pageMarkdown.shortestPathsMarkdown} section={this.pathfindingSection}\n                                      nextSection={true} nextSectionName={\"8. Maxflow-Mincut\"}\n                                      nextSectionDirectory={\"/AlgoVisual/documentation/pathfinding/maxflow-mincut\"}/>\n                    </Route>\n\n                    <Route exact path={\"/AlgoVisual/documentation/pathfinding/maxflow-mincut\"}>\n                        <MarkdownPage mainDirectory={\"/AlgoVisual/documentation/pathfinding\"}\n                                      sections={pathfindingSections} partNumber={8}\n                                      markdown={pageMarkdown.maxFlowMinCutMarkdown} section={this.pathfindingSection}\n                                      nextSection={false}/>\n                    </Route>\n                </Switch>\n\n                <ScrollToTopButton/>\n            </main>\n        )\n    }\n}\n\nexport default Documentation;","export function getBubbleSortAnimations(arr: number[]) {\n    let animations: [number, number, boolean][] = [];\n    bubbleSort(arr, animations);\n    return animations;\n}\n\nfunction bubbleSort(arr: number[], animations: [number, number, boolean][]) {\n    for (let i = 0; i < arr.length - 1; i++) {\n        let count = 0;\n        for (let j = 0; j < arr.length - 1 - i; j++) {\n            // comparing values\n            animations.push([j, j + 1, true]);\n            animations.push([j, j + 1, true]);\n            if (arr[j] > arr[j + 1]) {\n                animations.push([j, arr[j + 1], false]);\n                animations.push([j + 1, arr[j], false]);\n                swap(arr, j, j + 1);\n            } else {\n                count++;\n            }\n        }\n        if (count === arr.length - 1){\n            break;\n        }\n    }\n}\n\nfunction swap(arr: number[], i: number, j: number) {\n    let temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}","export function getMergeSortAnimations(array: number[]) {\n    let animations: [number, number, boolean][] = [];\n    const auxiliaryArray = array.slice();\n    mergeSort(array, 0, array.length - 1, auxiliaryArray, animations);\n    return animations;\n}\n\nfunction mergeSort(mainArray: number[], startIdx: number, endIdx: number, auxiliaryArray: number[], animations: [number, number, boolean][]) {\n    if (startIdx === endIdx) return;\n    const middleIdx = Math.floor((startIdx + endIdx) / 2);\n    mergeSort(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\n    mergeSort(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\n    merge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\n}\n\nfunction merge(mainArray: number[], startIdx: number, middleIdx: number, endIdx: number, auxiliaryArray: number[], animations: [number, number, boolean][]) {\n    let k = startIdx;\n    let i = startIdx;\n    let j = middleIdx + 1;\n    while (i <= middleIdx && j <= endIdx) {\n        // These are the values that we're comparing; we push them once\n        // to change their color.\n        animations.push([i, j, true]);\n        // These are the values that we're comparing; we push them a second\n        // time to revert their color.\n        animations.push([i, j, true]);\n        if (auxiliaryArray[i] <= auxiliaryArray[j]) {\n            // We overwrite the value at index k in the original array with the\n            // value at index i in the auxiliary array.\n            animations.push([k, auxiliaryArray[i], false]);\n            mainArray[k++] = auxiliaryArray[i++];\n        } else {\n            // We overwrite the value at index k in the original array with the\n            // value at index j in the auxiliary array.\n            animations.push([k, auxiliaryArray[j], false]);\n            mainArray[k++] = auxiliaryArray[j++];\n        }\n    }\n    while (i <= middleIdx) {\n        // These are the values that we're comparing; we push them once\n        // to change their color.\n        animations.push([i, i, true]);\n        // These are the values that we're comparing; we push them a second\n        // time to revert their color.\n        animations.push([i, i, true]);\n        // We overwrite the value at index k in the original array with the\n        // value at index i in the auxiliary array.\n        animations.push([k, auxiliaryArray[i], false]);\n        mainArray[k++] = auxiliaryArray[i++];\n    }\n    while (j <= endIdx) {\n        // These are the values that we're comparing; we push them once\n        // to change their color.\n        animations.push([j, j, true]);\n        // These are the values that we're comparing; we push them a second\n        // time to revert their color.\n        animations.push([j, j, true]);\n        // We overwrite the value at index k in the original array with the\n        // value at index j in the auxiliary array.\n        animations.push([k, auxiliaryArray[j], false]);\n        mainArray[k++] = auxiliaryArray[j++];\n    }\n}","export function getQuickSortAnimations(arr: number[]) {\n    let animations: [number, number, string, string][] = [];\n    quickSort(arr, 0, arr.length - 1, animations);\n    return animations;\n}\n\nfunction quickSort(arr: number[], l: number, h: number, animations: [number, number, string, string][]) {\n    if (l < h) {\n        let j = partition(arr, l, h, animations);\n        quickSort(arr, l, j, animations);\n        quickSort(arr, j + 1, h, animations);\n    }\n}\n\nfunction partition(arr: number[], l: number, h: number, animations: [number, number, string, string][]) {\n    let pivotIndex = randomIntFromInterval(l, h);\n    let swappedPivotIndex:any;\n    let pivot = arr[pivotIndex];\n    animations.push([pivotIndex, pivotIndex, 'pivot', 'insert']);\n    let i = l - 1;\n    let j = h + 1;\n    while (true) {\n        do {\n            i++;\n            animations.push([i, i, 'color', 'insert']);\n            animations.push([i, i, 'color', 'revert']);\n        } while (arr[i] < pivot);\n\n        do {\n            j--;\n            animations.push([j, j, 'color', 'insert']);\n            animations.push([j, j, 'color', 'revert']);\n        } while (arr[j] > pivot);\n\n        if (i >= j) {\n            animations.push([swappedPivotIndex, swappedPivotIndex, 'pivot', 'revert']);\n            return j;\n        }\n\n\n        animations.push([i, arr[j], 'swap', 'swap']);\n        animations.push([j, arr[i], 'swap', 'swap']);\n        swap(arr, i, j);\n\n\n        if (i === pivotIndex){\n            animations.push([j, j, 'pivot', 'insert']);\n            swappedPivotIndex = j;\n        } else if (j === pivotIndex){\n            animations.push([i, i, 'pivot', 'insert']);\n            swappedPivotIndex = i;\n        }\n    }\n}\n\nfunction swap(arr: number[], i: number, j: number) {\n    let temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n\nfunction randomIntFromInterval(min: number, max: number) {\n    // min and max included\n    return Math.floor(Math.random() * (max - min) + min);\n}","export function getHeapSortAnimations(arr: number[]) {\n    let animations: [number, number, boolean][] = [];\n    heapSort(arr, animations);\n    return animations;\n}\n\nfunction heapSort(arr: number[], animations: [number, number, boolean][]) {\n    let n = arr.length;\n    for (let k = n / 2; k >= 1; k--) {\n        sink(arr, k, n, animations);\n    }\n\n    let k = n;\n    while (k > 1) {\n        swap(arr, 1, k--, animations);\n        sink(arr, 1, k, animations);\n    }\n}\n\n// helper methods\nfunction sink(arr: number[], k: number, n: number, animations: [number, number, boolean][]) {\n    while (2 * k <= n) {\n        let j = 2 * k;\n        if (j < n && less(arr, j, j + 1)) {\n            j++;\n        }\n\n        if (!less(arr, k, j)) {\n            break;\n        }\n        swap(arr, k, j, animations);\n        k = j;\n    }\n}\n\nfunction less(arr: number[], i: number, j: number) {\n    return arr[i - 1] < arr[j - 1];\n}\n\nfunction swap(arr: number[], i: number, j: number, animations: [number, number, boolean][]) {\n    animations.push([i - 1, i - 1, true]);\n    animations.push([i - 1, i - 1, true]);\n    animations.push([i - 1, arr[j - 1], false]);\n    animations.push([j - 1, j - 1, true])\n    animations.push([j - 1, j - 1, true])\n    animations.push([j - 1, arr[i - 1], false]);\n    let temp = arr[i - 1];\n    arr[i - 1] = arr[j - 1];\n    arr[j - 1] = temp;\n}\n","export function getSelectionSortAnimations(arr: number[]) {\n    let animations: [number, number, boolean][] = [];\n    selectionSort(arr, animations);\n    return animations;\n}\n\nfunction selectionSort(arr: number[], animations: [number, number, boolean][]) {\n    for (let i = 0; i < arr.length; i++) {\n        let min = arr[i];\n        let minIndex = i;\n        for (let j = i; j < arr.length; j++) {\n            animations.push([j, j, true]);\n            animations.push([j, j, true]);\n            if (min > arr[j]){\n                min = arr[j];\n                minIndex = j;\n            }\n        }\n        animations.push([i, arr[minIndex], false]);\n        animations.push([minIndex, arr[i], false]);\n        swap(arr, i, minIndex);\n    }\n}\n\nfunction swap(arr: number[], i: number, j: number) {\n    let temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}","import React, {ChangeEvent, createRef} from \"react\";\nimport \"./SortingVisualizer.css\";\nimport {getInsertionSortAnimations} from \"./Algorithms/InsertionSort\";\nimport {getBubbleSortAnimations} from \"./Algorithms/BubbleSort\";\nimport {getMergeSortAnimations} from \"./Algorithms/MergeSort\";\nimport {getQuickSortAnimations} from \"./Algorithms/QuickSort\";\nimport {getHeapSortAnimations} from \"./Algorithms/HeapSort\";\nimport {getSelectionSortAnimations} from \"./Algorithms/SelectionSort\";\nimport {Slider} from \"@mui/material\";\n\n// This is the main color of the array bars.\nconst PRIMARY_COLOR = '#98d6e8';\n\n// This is the color of array bars that are being compared throughout the animations.\nconst SECONDARY_COLOR = '#33435d';\n\n// sorting algorithms\nconst options = [\"Bubble Sort\", \"Insertion Sort\", \"Selection Sort\", \"Merge Sort\", \"Quick Sort\", \"Heap Sort\"];\n\ntype Props = {};\n\ntype State = {\n    arr: number[],\n    numberOfBars: number,\n    sortingSpeed: number,\n    sortingAlgorithm: string,\n    showSortingOptions: boolean,\n    optionsDisabled: boolean,\n    animationLength: number,\n    sliderStyle: any,\n    keepTimeout: boolean\n}\n\nclass SortingVisualizer extends React.Component<Props, State> {\n    private dropdownSelection = createRef<HTMLDivElement>();\n    private dropdownCaret = createRef<HTMLDivElement>();\n    private runButton = createRef<HTMLButtonElement>();\n    private resetButton = createRef<HTMLButtonElement>();\n    private timer: any;\n\n    constructor(props: Props) {\n        super(props);\n        this.timer = null;\n        this.state = {\n            arr: [],\n            numberOfBars: 100,\n            sortingSpeed: 1,\n            sortingAlgorithm: \"Quick Sort\",\n            showSortingOptions: false,\n            optionsDisabled: false,\n            animationLength: 0,\n            sliderStyle: {\n                color: \"#33435d\",\n                \":hover\": {\n                    boxShadow: 0\n                },\n\n                '& .MuiSlider-thumb': {\n                    bgcolor: \"#85a4d9\",\n                    '&:focus, &:hover, &.Mui-active, &.Mui-focusVisible': {\n                        boxShadow: '0',\n                    },\n                },\n                '& .MuiSlider-valueLabel': {\n                    display: \"none\"\n                }\n            },\n            keepTimeout: true\n        };\n        this.resetArray = this.resetArray.bind(this);\n        this.changeWidthBasedOnSize = this.changeWidthBasedOnSize.bind(this);\n        this.numberOfBars = this.numberOfBars.bind(this);\n        this.sliderSpeed = this.sliderSpeed.bind(this);\n        this.runSortingAlgorithm = this.runSortingAlgorithm.bind(this);\n        this.buttonEnter = this.buttonEnter.bind(this);\n        this.buttonLeave = this.buttonLeave.bind(this);\n\n        // methods\n        this.showSortingAlgorithms = this.showSortingAlgorithms.bind(this);\n        this.closeSortingAlgorithms = this.closeSortingAlgorithms.bind(this);\n        this.displaySortingAlgorithms = this.displaySortingAlgorithms.bind(this);\n        this.changeAlgorithm = this.changeAlgorithm.bind(this);\n    }\n\n    componentDidMount() {\n        this.resetArray();\n        window.addEventListener('resize', () => {\n            this.resetArray();\n        }, true);\n    }\n\n    resetArray() {\n        // resize the array based on height of screen\n        if (!this.state.optionsDisabled) {\n            let screenHeight = document.getElementById(\"app-wrapper\")!.clientHeight;\n            let headerHeight = document.getElementById(\"header\")!.clientHeight;\n            let footerHeight = document.getElementById(\"footer\")!.clientHeight;\n            let containerHeight = screenHeight - headerHeight - footerHeight;\n            containerHeight = containerHeight < 600 ? footerHeight * 8 : containerHeight < 200 ? 1 : containerHeight;\n            let maxBarHeight = containerHeight - 100;\n            const arr = [];\n            for (let i = 0; i < this.state.numberOfBars; i++) {\n                arr.push(randomIntFromInterval(5, maxBarHeight));\n            }\n\n            // use changeBarsWidth here as a callback to ensure the arr is already updated!!\n            this.setState({arr}, () => this.changeWidthBasedOnSize(this.state.arr));\n        }\n    }\n\n    // change width of bars\n    changeWidthBasedOnSize(arr: number[]) {\n        if (arr.length <= 20) {\n            this.changeBarsWidth(60)\n        } else if (arr.length <= 40) {\n            this.changeBarsWidth(35)\n        } else if (arr.length <= 100) {\n            this.changeBarsWidth(10);\n        } else if (arr.length <= 150) {\n            this.changeBarsWidth(8);\n        } else if (arr.length <= 200) {\n            this.changeBarsWidth(5);\n        } else {\n            this.changeBarsWidth(3);\n        }\n    }\n\n    changeBarsWidth(width: number) {\n        let arrayBars = document.getElementsByClassName('array-bar');\n        for (let i = 0; i < arrayBars.length; i++) {\n            let bar = arrayBars[i] as HTMLElement;\n            bar.style.width = width + \"px\";\n        }\n    }\n\n    // displaying the settings\n    numberOfBars(e: Event, value: number | number[]) {\n        this.setState({numberOfBars: value as number}, () => {\n            // this ensures that the slider does not reset the array once the min/max is reached\n            if (this.state.numberOfBars > 10 && this.state.numberOfBars < 250) {\n                this.resetArray()\n            }\n        });\n    }\n\n    sliderSpeed(e: Event, value: number | number[]) {\n        this.setState({sortingSpeed: value as number});\n    }\n\n    // button hover settings\n    buttonEnter(e: React.MouseEvent<HTMLButtonElement>) {\n        if (!this.state.optionsDisabled) {\n            e.currentTarget.style.color = \"#98d6e8\";\n        }\n    }\n\n    buttonLeave(e: React.MouseEvent<HTMLButtonElement>) {\n        if (!this.state.optionsDisabled) {\n            e.currentTarget.style.color = \"#fff\";\n        }\n    }\n\n    // methods for dropdown menu\n    showSortingAlgorithms(e: React.MouseEvent) {\n        // ensures that you close menu when clicked again\n        if (!this.state.showSortingOptions) {\n            this.setState({showSortingOptions: true}, () => this.displaySortingAlgorithms());\n            // not sure why this works but will figure out soon\n            // makes dropdown work magically!\n            e.stopPropagation();\n            document.addEventListener(\"click\", this.closeSortingAlgorithms);\n        }\n    }\n\n    closeSortingAlgorithms() {\n        this.setState({showSortingOptions: false}, () => this.displaySortingAlgorithms());\n        document.removeEventListener(\"click\", this.closeSortingAlgorithms)\n    }\n\n    displaySortingAlgorithms() {\n        if (this.state.showSortingOptions) {\n            this.dropdownSelection.current!.style.display = \"block\";\n            this.dropdownCaret.current!.style.transform = \"rotate(180deg)\";\n            this.dropdownCaret.current!.style.transition = \"all 250ms linear\";\n        } else {\n            this.dropdownSelection.current!.style.display = \"none\";\n            this.dropdownCaret.current!.style.transform = \"rotate(0deg)\";\n            this.dropdownCaret.current!.style.transition = \"all 250ms linear\";\n        }\n    }\n\n    changeAlgorithm(option: string) {\n        this.setState({sortingAlgorithm: option});\n    }\n\n    // sorting algorithms\n    bubbleSort() {\n        let animations = getBubbleSortAnimations(this.state.arr);\n        this.sort(animations, 2);\n    }\n\n    insertionSort() {\n        let animations = getInsertionSortAnimations(this.state.arr);\n        this.sort(animations, 3);\n    }\n\n    selectionSort() {\n        let animations = getSelectionSortAnimations(this.state.arr);\n        this.sort(animations, 2);\n    }\n\n    mergeSort() {\n        const animations = getMergeSortAnimations(this.state.arr);\n        this.sort(animations, 3);\n    }\n\n    quickSort() {\n        let animations = getQuickSortAnimations(this.state.arr);\n        this.quickSortAnimations(animations);\n    }\n\n    heapSort() {\n        let animations = getHeapSortAnimations(this.state.arr);\n        this.sort(animations, 3);\n    }\n\n    quickSortAnimations(animations: [number, number, string, string][]) {\n        let animationLength = animations.length * this.state.sortingSpeed;\n        this.enableSettings(animationLength);\n        for (let i = 0; i < animations.length; i++) {\n            let arrayBars = document.getElementsByClassName('array-bar');\n            if (arrayBars !== undefined) {\n                let animationType = animations[i][2];\n                if (animationType === 'color') {\n                    let [barOneIdx, barTwoIdx] = animations[i];\n                    let barOne = arrayBars[barOneIdx] as HTMLElement;\n                    let barTwo = arrayBars[barTwoIdx] as HTMLElement;\n                    let colorState = animations[i][3];\n                    let color = colorState === 'insert' ? SECONDARY_COLOR : PRIMARY_COLOR;\n                    // keep track of timer to cancel timer operations once the component is unmounted\n                    let t = setTimeout(() => {\n                        if (barOne !== undefined || barTwo !== undefined) {\n                            barOne.style.backgroundColor = color;\n                            barTwo.style.backgroundColor = color;\n                        }\n                    }, i * this.state.sortingSpeed);\n                    // clear timeout if bars are undefined (component is unmounted)\n                    if (barOne === undefined || barTwo === undefined) {\n                        clearTimeout(t);\n                    }\n                } else if (animationType === 'swap') {\n                    const [barOneIdx, newHeight] = animations[i];\n                    const barOne = arrayBars[barOneIdx] as HTMLElement;\n                    // keep track of timer to cancel timer operations once the component is unmounted\n                    let t = setTimeout(() => {\n                        if (barOne !== undefined) {\n                            barOne.style.height = newHeight + `px`;\n                        }\n                    }, i * this.state.sortingSpeed);\n                    // clear timeout if bars are undefined (component is unmounted)\n                    if (barOne === undefined) {\n                        clearTimeout(t);\n                    }\n                } else if (animationType === 'pivot') {\n                    let [barOneIdx, barTwoIdx] = animations[i];\n                    let barOne = arrayBars[barOneIdx] as HTMLElement;\n                    let barTwo = arrayBars[barTwoIdx] as HTMLElement;\n                    let colorState = animations[i][3];\n                    let color = colorState === 'insert' ? '#83f57f' : PRIMARY_COLOR;\n                    // keep track of timer to cancel timer operations once the component is unmounted\n                    let t = setTimeout(() => {\n                        if (barOne !== undefined || barTwo !== undefined) {\n                            barOne.style.backgroundColor = color;\n                            barTwo.style.backgroundColor = color;\n                        }\n                    }, i * this.state.sortingSpeed);\n                    // clear timeout if bars are undefined (component is unmounted)\n                    if (barOne === undefined || barTwo === undefined) {\n                        clearTimeout(t);\n                    }\n                }\n\n            }\n        }\n    }\n\n    // sorting helper method\n    sort(animations: [number, number, boolean][], modulus: number) {\n        let animationLength = animations.length * this.state.sortingSpeed;\n        this.enableSettings(animationLength);\n        for (let i = 0; i < animations.length; i++) {\n            let arrayBars = document.getElementsByClassName('array-bar');\n            if (arrayBars !== undefined) {\n                let isColorChange = animations[i][2];\n                if (isColorChange) {\n                    let [barOneIdx, barTwoIdx] = animations[i];\n                    let barOne = arrayBars[barOneIdx] as HTMLElement;\n                    let barTwo = arrayBars[barTwoIdx] as HTMLElement;\n                    let color = i % modulus === 0 ? SECONDARY_COLOR : PRIMARY_COLOR;\n\n                    // keep track of timer to cancel timer operations once the component is unmounted\n                    let t = setTimeout(() => {\n                        if (barOne !== undefined || barTwo !== undefined) {\n                            barOne.style.backgroundColor = color;\n                            barTwo.style.backgroundColor = color;\n                        }\n                    }, i * this.state.sortingSpeed);\n                    // clear timeout if bars are undefined (component is unmounted)\n                    if (barOne === undefined || barTwo === undefined) {\n                        clearTimeout(t);\n                    }\n                } else {\n                    const [barOneIdx, newHeight] = animations[i];\n                    const barOne = arrayBars[barOneIdx] as HTMLElement;\n                    // keep track of timer to cancel timer operations once the component is unmounted\n                    let t = setTimeout(() => {\n                        if (barOne !== undefined) {\n                            barOne.style.height = newHeight + `px`;\n                        }\n                    }, i * this.state.sortingSpeed);\n                    // clear timeout if bars are undefined (component is unmounted)\n                    if (barOne === undefined) {\n                        clearTimeout(t);\n                    }\n                }\n            }\n        }\n    }\n\n    // run the sorting algorithm and disable buttons\n    runSortingAlgorithm() {\n        this.setState({optionsDisabled: true}, () => {\n            switch (this.state.sortingAlgorithm) {\n                case 'Bubble Sort':\n                    this.bubbleSort();\n                    break;\n                case 'Insertion Sort':\n                    this.insertionSort();\n                    break;\n                case 'Selection Sort':\n                    this.selectionSort();\n                    break;\n                case 'Merge Sort':\n                    this.mergeSort();\n                    break;\n                case 'Quick Sort':\n                    this.quickSort();\n                    break;\n                case 'Heap Sort':\n                    this.heapSort();\n                    break;\n            }\n        });\n        const buttons = document.getElementsByClassName('sidebar-button');\n        for (let i = 0; i < buttons.length; i++) {\n            let button = buttons[i] as HTMLButtonElement;\n            button.style.color = \"#f5a0a0\";\n            button.style.cursor = \"revert\";\n        }\n\n        this.setState({\n            sliderStyle: {\n                '& .MuiSlider-thumb': {\n                    bgcolor: \"#f5a0a0\",\n                    \":hover\": {\n                        boxShadow: 0\n                    },\n                },\n            } as const\n        });\n    }\n\n    // enable settings once the the animation is over\n    enableSettings(animationLength: number) {\n        setTimeout(() => {\n            this.setState({\n                optionsDisabled: false,\n                sliderStyle: {\n                    color: \"#33435d\",\n                    \":hover\": {\n                        boxShadow: 0\n                    },\n                    '& .MuiSlider-thumb': {\n                        bgcolor: \"#85a4d9\",\n                        \":hover\": {\n                            boxShadow: 0\n                        },\n                    },\n                    '& .MuiSlider-valueLabel': {\n                        display: \"none\"\n                    }\n                } as const\n            });\n\n            const buttons = document.getElementsByClassName('sidebar-button');\n            for (let i = 0; i < buttons.length; i++) {\n                let button = buttons[i] as HTMLButtonElement;\n                button.style.color = \"#fff\";\n                button.style.cursor = \"pointer\";\n            }\n        }, animationLength);\n    }\n\n    render() {\n        const {arr} = this.state;\n        let bars = arr.map((value, idx) => (\n            <div className=\"array-bar\"\n                 key={idx}\n                 style={{backgroundColor: PRIMARY_COLOR, height: value + `px`}}>\n            </div>\n        ))\n\n        return (\n            <main className=\"main-sidebar\">\n                <div className={\"sidebar-wrapper\"}>\n                    <div className={\"sidebar\"}>\n                        <div className={\"sidebar-settings\"}>\n                            <div className={\"sidebar-setting\"}>\n                                <p> Control number of bars </p>\n                                <p> {this.state.numberOfBars} bars </p>\n                                <Slider sx={this.state.sliderStyle} disabled={this.state.optionsDisabled} min={10}\n                                        onChange={this.numberOfBars} max={250} defaultValue={100}\n                                        valueLabelDisplay=\"auto\"/>\n                            </div>\n\n                            <div className={\"sidebar-setting\"}>\n                                <p> Control visualizer speed </p>\n                                <p> {this.state.sortingSpeed} ms </p>\n                                <Slider sx={this.state.sliderStyle} disabled={this.state.optionsDisabled} min={1}\n                                        onChange={this.sliderSpeed} max={100} defaultValue={1}\n                                        valueLabelDisplay=\"auto\"/>\n                            </div>\n\n                            <div className={\"sidebar-setting\"}>\n                                <p> Choose an algorithm </p>\n\n                                <div className={\"selection-dropdown\"} onClick={this.showSortingAlgorithms}>\n                                    <div className={\"current-option\"}>\n                                        <p> {this.state.sortingAlgorithm} </p>\n                                    </div>\n\n                                    <div className={\"caret-down\"}>\n                                        <i className=\"fas fa-caret-down\" ref={this.dropdownCaret}> </i>\n                                    </div>\n                                </div>\n                                <div className={\"selection-options\"} ref={this.dropdownSelection}>\n                                    <ul>\n                                        {\n                                            options.map(option => (\n                                                <div onClick={() => this.changeAlgorithm(option)}\n                                                     key={option}> {option} </div>\n                                            ))\n                                        }\n                                    </ul>\n                                </div>\n\n                                <button disabled={this.state.optionsDisabled} className={\"sidebar-button\"}\n                                        onClick={this.runSortingAlgorithm}\n                                        onMouseEnter={this.buttonEnter} onMouseLeave={this.buttonLeave}\n                                        ref={this.runButton}> Run\n                                </button>\n                            </div>\n\n                            <div className={\"sidebar-setting\"}>\n                                <p> Reset the array </p>\n                                <button disabled={this.state.optionsDisabled} className={\"sidebar-button\"}\n                                        onClick={this.resetArray}\n                                        onMouseEnter={this.buttonEnter} onMouseLeave={this.buttonLeave}\n                                        ref={this.resetButton}> Reset\n                                </button>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n\n                <div className={\"main-content\"}>\n                    <div id={\"sorting-visualizer\"}>\n                        {bars}\n                    </div>\n                </div>\n            </main>\n        );\n    }\n}\n\nexport default SortingVisualizer;\n\nfunction randomIntFromInterval(min: number, max: number) {\n    // min and max included\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}","export function getInsertionSortAnimations(arr: number[]) {\n    let animations: [number, number, boolean][] = [];\n    insertionSort(arr, animations);\n    return animations;\n}\n\nfunction insertionSort(arr: number[], animations: [number, number, boolean][]) {\n    for (let i = 1; i < arr.length; i++) {\n        let key = arr[i];\n        let j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            animations.push([j + 1, j, true]);\n            animations.push([j + 1, j, true]);\n            animations.push([j + 1, arr[j], false]);\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        animations.push([j + 1, i, true]);\n        animations.push([j + 1, i, true]);\n        animations.push([j + 1, key, false]);\n        arr[j + 1] = key;\n    }\n}","import React from \"react\";\nimport \"./GridNode.css\";\n\ntype Props = {\n    col: number,\n    isFinish: boolean,\n    isStart: boolean,\n    isWall: boolean,\n    onMouseDown?: React.MouseEventHandler<HTMLDivElement>,\n    onMouseEnter?: React.MouseEventHandler<HTMLDivElement>,\n    onMouseUp?: React.MouseEventHandler<HTMLDivElement>,\n    onMouseOver?: React.MouseEventHandler<HTMLDivElement>,\n    onTouchStart?: React.TouchEventHandler<HTMLDivElement>,\n    onTouchMove?: React.TouchEventHandler<HTMLDivElement>,\n    onTouchEnd?: React.TouchEventHandler<HTMLDivElement>\n    row: number,\n    style?: any\n};\ntype State = {};\n\nclass GridNode extends React.Component<Props, State> {\n    constructor(props: Props) {\n        super(props);\n    }\n\n    render() {\n        const {col, isFinish, isStart, isWall, onMouseDown, onMouseOver, onMouseEnter, onMouseUp, row, onTouchStart, onTouchMove, onTouchEnd} = this.props;\n        const className = isFinish ? 'node node-finish' : isStart ? 'node node-start' : isWall ? 'node node-wall' : 'node';\n        const nodeID = \"node-\" + col + \"-\" + row\n        return (\n            <div id={nodeID} className={className} onMouseOver={onMouseOver} onMouseDown={onMouseDown} onMouseEnter={onMouseEnter}\n                 onMouseUp={onMouseUp} style={this.props.style} onTouchStart={onTouchStart} onTouchMove={onTouchMove} onTouchEnd={onTouchEnd}/>\n        );\n    }\n}\n\nexport default GridNode;","class IndexMinPQ<Type> {\n    private n: number;\n    private maxN: number;\n    private readonly keys: Type[];\n    private readonly pq: number[];\n    private readonly qp: number[];\n\n    constructor(maxN: number, comparator?: any) {\n        this.n = 0;\n        this.maxN = maxN;\n        this.keys = [];\n        this.pq = [];\n        this.qp = [];\n        for (let i = 0; i <= maxN; i++) {\n            this.pq.push(-1);\n            this.qp.push(-1);\n        }\n    }\n\n    isEmpty(){\n        return this.n === 0;\n    }\n\n    contains(i: number){\n        return this.qp[i] !== -1;\n    }\n\n    insert(i: number, key: Type){\n        ++this.n;\n        this.pq[this.n] = i;\n        this.qp[i] = this.n; // big typo (was pq)\n        this.keys[i] = key;\n        this.swim(this.n);\n    }\n\n    delMin(){\n        let min = this.pq[1];\n        this.exch(1, this.n--);\n        this.sink(1);\n        this.qp[min] = -1;\n        this.pq[this.n+1] = -1;\n        return min;\n     }\n\n     print(){\n        console.log(this.pq);\n     }\n\n     decreaseKey(i:number, key:Type){\n        this.keys[i] = key;\n        this.swim(this.qp[i]);\n     }\n\n    private exch(i:number, j: number){\n        let temp = this.pq[i];\n        this.pq[i] = this.pq[j];\n        this.pq[j] = temp;\n        this.qp[this.pq[i]] = i;\n        this.qp[this.pq[j]] = j;\n    }\n\n    private greater(i:number, j:number){\n        return  this.keys[this.pq[i]] > this.keys[this.pq[j]];\n    }\n\n    private swim(k: number){\n        while(k > 1 && this.greater(Math.floor(k/2), k)){\n            this.exch(k, Math.floor(k/2));\n            k = Math.floor(k/2);\n        }\n    }\n\n    private sink(k: number){\n        while (2 * k <= this.n){\n            let j = 2 * k;\n            if (j < this.n && this.greater(j, j+1)) j++;\n            if (!this.greater(k, j)) break;\n            this.exch(k, j);\n            k = j;\n        }\n    }\n}\n\nexport default IndexMinPQ;","import IndexMinPQ from \"./IndexMinPQ\";\nimport {Node} from \"../Node/Node\";\n\n// uses an indexed min pq to find the shortest path\nexport function dijkstraSP(s: Node, t: Node, grid: Node[][]) {\n    let gridDimensions = grid.length * grid[0].length;\n    let pq = new IndexMinPQ<Number>(gridDimensions);\n    let visitedNodes: Node[] = [];\n    const edgeTo: Node[] = [];\n    s.weight = 0;\n    let colSize = grid[0].length;\n    pq.insert(getIndex(s.row, s.col, colSize), s.weight);\n    while (!pq.isEmpty()) {\n        let nodeIndex = pq.delMin();\n        let row = Math.floor(nodeIndex / colSize);\n        let col = nodeIndex - (row * colSize);\n        let minNode: Node = grid[row][col];\n        if (minNode.isWall) continue;\n        if (minNode.weight === Infinity) return visitedNodes;\n        minNode.isVisited = true;\n        visitedNodes.push(minNode);\n        if (minNode === t) return visitedNodes;\n        const neighbors = getNeighbors(minNode, grid);\n        for (const neighbor of neighbors){\n            relax(neighbor, visitedNodes, pq, colSize);\n        }\n    }\n    return visitedNodes;\n}\n\nfunction relax(v: Node, visitedNodes: Node[], pq: IndexMinPQ<Number>, colSize: number){\n    const vIndex = getIndex(v.row, v.col, colSize);\n    if (pq.contains(vIndex)){\n        pq.decreaseKey(vIndex, v.weight);\n    } else {\n        pq.insert(vIndex, v.weight);\n    }\n}\n\nfunction getNeighbors(v: Node, grid: Node[][]){\n    const {row, col} = v;\n    const neighbors:Node[] = [];\n\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1])\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col])\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1])\n\n    let unvisitedNeighbors = neighbors.filter(neighbor => !neighbor.isVisited);\n    for (const neighbor of unvisitedNeighbors){\n        neighbor.weight = v.weight + 1;\n        neighbor.previousNode = v;\n    }\n    return unvisitedNeighbors;\n}\n\nfunction getIndex(row: number, col: number, colSize: number) {\n    return (row * colSize) + col;\n}\n\nexport function shortestPath(t: Node) {\n    const shortestPath = [];\n    let currentNode: Node | null = t;\n    while (currentNode !== null) {\n        shortestPath.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return shortestPath;\n}\n\nexport default dijkstraSP;","import {Node} from \"../Node/Node\";\n\nexport function dfsVisited(s: Node, t: Node, grid:Node[][]){\n    const visitedNodes:Node[] = [];\n    dfs(s, t, grid, visitedNodes);\n    return visitedNodes;\n}\n\nfunction dfs(v: Node, t: Node, grid:Node[][], visitedNodes: Node[]){\n    if (grid[t.row][t.col].isVisited){\n        return;\n    }\n\n    if (v.isWall) return;       \n\n    v.isVisited = true;\n    visitedNodes.push(v);\n    const {row, col} = v;\n\n    if (validVertex(row - 1, col, grid) && !grid[row-1][col].isVisited) {\n        grid[row-1][col].previousNode = v;\n        dfs(grid[row - 1][col], t, grid, visitedNodes);\n    }\n    if (validVertex(row, col + 1, grid) && !grid[row][col+1].isVisited) {\n        grid[row][col+1].previousNode = v;\n        dfs(grid[row][col + 1], t, grid, visitedNodes);\n    }\n    if (validVertex(row + 1, col, grid) && !grid[row + 1][col].isVisited) {\n        grid[row+1][col].previousNode = v;\n        dfs(grid[row + 1][col], t, grid, visitedNodes);\n    }\n    if (validVertex(row, col - 1, grid) && !grid[row][col-1].isVisited) {\n        grid[row][col-1].previousNode = v;\n        dfs(grid[row][col - 1], t, grid, visitedNodes);\n    }\n}\n\nfunction validVertex(row: number, col: number, grid: Node[][]){\n    return !(row < 0 || row >= grid.length || col < 0 || col >= grid[0].length);\n}\n\nexport function dfsPath(t: Node){\n    const shortestPath = [];\n    let currentNode: Node | null = t;\n    while (currentNode !== null) {\n        shortestPath.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return shortestPath;\n}","import {Node} from \"../Node/Node\";\n\nexport function bfsVisited(s: Node, t: Node, grid: Node[][]) {\n    const visitedNodes: Node[] = [];\n    const queue: Node[] = [];\n    s.isVisited = true;\n    s.weight = 0;\n    queue.unshift(s);\n    visitedNodes.push(s);\n    while (queue.length !== 0) {\n        const node:Node = queue.shift() as Node;\n        let neighbors = getNeighbors(node, grid);\n        for(const neighbor of neighbors){\n            if (neighbor.isWall) continue;\n            neighbor.previousNode = node;\n            neighbor.weight = node.weight + 1;\n            neighbor.isVisited = true;\n            queue.push(neighbor);\n            visitedNodes.push(neighbor);\n        }\n        if (node === t) return visitedNodes;\n    }\n\n    return visitedNodes;\n}\n\nfunction getNeighbors(v: Node, grid: Node[][]) {\n    const {row, col} = v;\n    const neighbors: Node[] = [];\n    if (validVertex(row + 1, col, grid) && !grid[row + 1][col].isVisited) {\n        neighbors.unshift(grid[row + 1][col]);\n    }\n    if (validVertex(row, col + 1, grid) && !grid[row][col + 1].isVisited) {\n        neighbors.unshift(grid[row][col + 1]);\n    }\n    if (validVertex(row - 1, col, grid) && !grid[row - 1][col].isVisited) {\n        neighbors.unshift(grid[row-1][col]);\n    }\n    if (validVertex(row, col - 1, grid) && !grid[row][col - 1].isVisited) {\n        neighbors.unshift(grid[row][col-1]);\n    }\n    return neighbors;\n}\n\nfunction validVertex(row: number, col: number, grid: Node[][]) {\n    return !(row < 0 || row >= grid.length || col < 0 || col >= grid[0].length);\n}\n\nexport function bfsPath(t: Node) {\n    const shortestPath = [];\n    let currentNode: Node | null = t;\n    while (currentNode !== null) {\n        shortestPath.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return shortestPath;\n}","import {Node} from \"../Node/Node\";\n\nexport function recursiveDivision(grid: Node[][]) {\n    const walls: Node[] = [];\n    addOuterWalls(grid, walls);\n    addInnerWalls(true, 1, grid[0].length - 2, 1, grid.length - 2, grid, walls);\n    addOuterWalls(grid, walls)\n    return walls;\n}\n\nfunction addOuterWalls(grid: Node[][], walls: Node[]) {\n    for (let i = 0; i < grid.length; i++) {\n        if (i == 0 || i == (grid.length - 1)) {\n            for (let j = 0; j < grid[0].length; j++) {\n                grid[i][j].isWall = true;\n                walls.push(grid[i][j]);\n            }\n        } else {\n            grid[i][0].isWall = true;\n            grid[i][grid[0].length - 1].isWall = true;\n            walls.push(grid[i][0]);\n            walls.push(grid[i][grid[0].length - 1])\n        }\n    }\n}\n\nfunction addInnerWalls(h: boolean, minX: number, maxX: number, minY: number, maxY: number, grid: Node[][], walls: Node[]) {\n    if (h) {\n        if (maxX - minX < 2) {\n            return;\n        }\n        let y = Math.floor(randomNumber(minY, maxY) / 2) * 2;\n        addHWall(minX, maxX, y, grid, walls);\n        addInnerWalls(!h, minX, maxX, minY, y - 1, grid, walls);\n        addInnerWalls(!h, minX, maxX, y + 1, maxY, grid, walls);\n    } else {\n        if (maxY - minY < 2) {\n            return;\n        }\n        let x = Math.floor(randomNumber(minX, maxX) / 2) * 2;\n        addVWall(minY, maxY, x, grid, walls);\n        addInnerWalls(!h, minX, x - 1, minY, maxY, grid, walls);\n        addInnerWalls(!h, x + 1, maxX, minY, maxY, grid, walls);\n    }\n}\n\nfunction addHWall(minX: number, maxX: number, y: number, grid: Node[][], walls: Node[]) {\n    let hole = Math.floor(randomNumber(minX, maxX) / 2) * 2 + 1;\n    for (let i = minX; i <= maxX; i++) {\n        if (i === hole){\n            grid[y][i].isWall = false;\n        } else {\n            grid[y][i].isWall = true;\n            walls.push(grid[y][i]);\n        }\n    }\n}\n\nfunction addVWall(minY: number, maxY: number, x: number, grid: Node[][], walls: Node[]) {\n    let hole = Math.floor(randomNumber(minY, maxY) / 2) * 2 + 1;\n\n    for (let i = minY; i <= maxY; i++) {\n        if (i === hole){\n            grid[i][x].isWall = false;\n        } else {\n            grid[i][x].isWall = true;\n            walls.push(grid[i][x]);\n        }\n    }\n}\n\nfunction randomNumber(min: number, max: number) {\n    // min and max included\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}","import React, {createRef} from \"react\";\nimport GridNode from \"./Node/GridNode\";\nimport \"./PathfindingVisualizer.css\";\nimport {dijkstraSP, shortestPath} from \"./Algorithms/DijkstraSP\";\nimport {Node} from \"./Node/Node\";\nimport {dfsPath, dfsVisited} from \"./Algorithms/DFS\";\nimport {bfsPath, bfsVisited} from \"./Algorithms/BFS\";\nimport update from 'immutability-helper';\nimport {recursiveDivision} from \"./MazeGeneration/RecursiveDivision\";\n\nconst options = [\"DFS\", \"BFS\", \"Dijkstra\", \"A*\"];\ntype Props = {};\ntype State = {\n    grid: Node[][],\n    initialGrid: Node[][],\n    mouseIsPressed: boolean,\n    rows: number,\n    cols: number,\n    showAlgorithms: boolean,\n    optionsDisabled: boolean,\n    algorithm: string\n    nodeStyle: any\n};\n\nconst START_NODE_ROW = 3;\nconst START_NODE_COL = 3;\nconst FINISH_NODE_ROW = 27;\nconst FINISH_NODE_COL = 27;\nconst VISITED_NODES_SPEED = 20;\nconst SHORTEST_PATH_SPEED = 30;\n\nclass PathfindingVisualizer extends React.Component<Props, State> {\n    private dropdownSelection = createRef<HTMLDivElement>();\n    private dropdownCaret = createRef<HTMLDivElement>();\n\n    constructor(props: Props) {\n        super(props);\n        this.state = {\n            grid: [],\n            initialGrid: [],\n            mouseIsPressed: false,\n            rows: 31,\n            cols: 31,\n            algorithm: \"Dijkstra\",\n            showAlgorithms: false,\n            optionsDisabled: false,\n            nodeStyle: {width: \"20px\", height: \"20px\"}\n        }\n        this.showAlgorithms = this.showAlgorithms.bind(this);\n        this.closeAlgorithms = this.closeAlgorithms.bind(this);\n        this.changeAlgorithm = this.changeAlgorithm.bind(this);\n        this.runAlgorithm = this.runAlgorithm.bind(this);\n    }\n\n    componentDidMount() {\n        const grid = this.getInitialGrid();\n        this.resizeGrid();\n        this.setState({grid: grid});\n        let root = document.getElementById(\"grid-wrapper\");\n        let total = 0;\n        root!.ontouchmove = (e) => {\n            // why does this work??? is this a reference to state grid??? is it cause of pass by val??\n            const wallsGrid: Node[][] = this.state.grid.slice();\n            for (let i = 0; i < e.changedTouches.length; i++) {\n                let element = e.changedTouches[i];\n                let v = document.elementFromPoint(element.clientX, element.clientY);\n                if (v != null) {\n                    if (v.classList.contains(\"node\") && (!v.classList.contains(\"node-start\") && (!v.classList.contains(\"node-finish\")))) {\n                        const line = v.id.split(\"-\");\n                        const col = parseInt(line[1]);\n                        const row = parseInt(line[2]);\n                        total += 10;\n                        v.className = 'node node-wall';\n                        // results in more efficient results...why?\n                        // maybe cause pass by value returns a reference (like in java)????\n                        wallsGrid[row][col].isWall = !wallsGrid[row][col].isWall;\n                    }\n                }\n            }\n        }\n\n        root!.onmousedown = (e) => {\n            // breaks walls for  grid, do not remove\n            // e.stopImmediatePropagation(); (didn't allow elements to be placed on first click)\n            e.preventDefault();\n            this.setState({mouseIsPressed: true});\n        }\n        root!.onmouseup = (e) => {\n            // breaks walls grid, do not remove\n            e.preventDefault();\n            e.stopImmediatePropagation();\n            this.setState({mouseIsPressed: false});\n        }\n\n        window.addEventListener('resize', () => {\n            this.resizeGrid();\n        }, true);\n    }\n\n    resizeGrid() {\n        let COLS = this.state.cols;\n        let mainContentWidth = document.getElementById(\"main\")!.offsetWidth;\n        let dimension = Math.floor(mainContentWidth / (COLS * 2.5)) + \"px\";\n        this.setState({\n            nodeStyle: {\n                width: dimension,\n                height: dimension\n            }\n        });\n    }\n\n    showAlgorithms(e: React.MouseEvent) {\n        // ensures that you close menu when clicked again\n        console.log(this.state.showAlgorithms);\n        if (!this.state.showAlgorithms) {\n            console.log(this.state.showAlgorithms);\n            this.setState({showAlgorithms: true}, () => this.displayAlgorithms());\n            // not sure why this works but will figure out soon\n            // makes dropdown work magically!\n            e.stopPropagation();\n            document.addEventListener(\"click\", this.closeAlgorithms);\n        }\n    }\n\n    closeAlgorithms() {\n        this.setState({showAlgorithms: false}, () => this.displayAlgorithms());\n        document.removeEventListener(\"click\", this.closeAlgorithms)\n    }\n\n    displayAlgorithms() {\n        if (this.state.showAlgorithms) {\n            this.dropdownSelection.current!.style.display = \"block\";\n            this.dropdownCaret.current!.style.transform = \"rotate(180deg)\";\n            this.dropdownCaret.current!.style.transition = \"all 250ms linear\";\n        } else {\n            this.dropdownSelection.current!.style.display = \"none\";\n            this.dropdownCaret.current!.style.transform = \"rotate(0deg)\";\n            this.dropdownCaret.current!.style.transition = \"all 250ms linear\";\n        }\n    }\n\n    changeAlgorithm(option: string) {\n        this.setState({algorithm: option});\n    }\n\n    runAlgorithm() {\n        this.setState({optionsDisabled: true}, () => {\n            switch (this.state.algorithm) {\n                case 'DFS':\n                    this.visualizeDFS();\n                    break;\n                case 'BFS':\n                    this.visualizeBFS();\n                    break;\n                case 'Dijkstra':\n                    this.visualizeDijkstra();\n                    break;\n            }\n        });\n    }\n\n    getNewGridWithWallToggled(grid: Node[][], row: number, col: number) {\n        return update(grid, {\n            [row]: {[col]: {isWall: {$set: !grid[row][col].isWall}}}\n        });\n    }\n\n    handleMouseDown(row: number, col: number) {\n        const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\n        this.setState({grid: newGrid, initialGrid: newGrid, mouseIsPressed: true});\n    }\n\n    handleMouseEnter(row: number, col: number) {\n        console.log(this.state.mouseIsPressed)\n        if (!this.state.mouseIsPressed) return;\n        const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\n        this.setState({grid: newGrid, initialGrid: newGrid});\n    }\n\n    handleMouseUp() {\n        this.setState({mouseIsPressed: false});\n    }\n\n\n    handleMouseLeave() {\n        this.setState({mouseIsPressed: false});\n    }\n\n    recursiveDivision() {\n        const wallsGrid = this.state.grid.slice();\n        let walls = recursiveDivision(wallsGrid);\n        let totalTime = 0;\n        for (let i = 0; i < walls.length; i++) {\n            const v = walls[i];\n            totalTime += 10;\n            setTimeout(() => {\n                const nodeID = \"node-\" + v.col + \"-\" + v.row;\n                document.getElementById(nodeID)!.className = 'node node-wall';\n            }, i * 10)\n        }\n\n    }\n\n    visualizeDFS() {\n        this.setState((state) => ({initialGrid: state.grid}));\n        const {grid} = this.state;\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n        const visitedNodes = dfsVisited(startNode, finishNode, grid);\n        const pathForDFS = dfsPath(finishNode);\n        this.animateVisited(visitedNodes, pathForDFS);\n        // ensures the animation can be ran again once it is over\n        this.copyGrid();\n    }\n\n    visualizeBFS() {\n        this.setState((state) => ({initialGrid: state.grid}));\n        const {grid} = this.state;\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n        const visitedNodes = bfsVisited(startNode, finishNode, grid);\n        const pathForBFS = bfsPath(finishNode);\n        this.animateVisited(visitedNodes, pathForBFS);\n        // ensures the animation can be ran again once it is over\n        this.copyGrid();\n    }\n\n    visualizeDijkstra() {\n        this.setState((state) => ({initialGrid: state.grid}));\n        const {grid} = this.state;\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n        const visitedNodes = dijkstraSP(startNode, finishNode, grid);\n        const pathNodes = shortestPath(finishNode);\n        this.animateVisited(visitedNodes, pathNodes);\n        this.copyGrid();\n    }\n\n    animateVisited(visitedNodes: Node[], pathNodes: Node[]) {\n        for (let i = 0; i <= visitedNodes.length; i++) {\n            if (i === visitedNodes.length) {\n                setTimeout(() => {\n                    this.animatePath(pathNodes);\n                }, i * VISITED_NODES_SPEED);\n            } else {\n                setTimeout(() => {\n                    const node = visitedNodes[i];\n                    const nodeID = \"node-\" + node.col + \"-\" + node.row;\n                    document.getElementById(nodeID)!.className = 'node node-visited';\n                }, i * VISITED_NODES_SPEED);\n            }\n        }\n    }\n\n    animatePath(pathNodes: Node[]) {\n        for (let i = 0; i < pathNodes.length; i++) {\n            setTimeout(() => {\n                const node = pathNodes[i];\n                const nodeID = \"node-\" + node.col + \"-\" + node.row;\n                document.getElementById(nodeID)!.className = 'node node-shortest-path';\n            }, i * SHORTEST_PATH_SPEED);\n        }\n    }\n\n    copyGrid() {\n        const grid: Node[][] = [];\n        this.setState({grid: grid}, () => {\n            this.setState({grid: this.getCopyGrid()})\n        });\n    }\n\n    clearGrid() {\n        const grid: Node[][] = [];\n        this.setState({grid: grid}, () => {\n            this.setState({grid: this.getInitialGrid()})\n        });\n    }\n\n    getCopyGrid() {\n        const grid = [];\n        for (let row = 0; row < this.state.rows; row++) {\n            const currentRow = [];\n            for (let col = 0; col < this.state.cols; col++) {\n                if (this.state.initialGrid[row][col].isWall) {\n                    currentRow.push(this.state.initialGrid[row][col]);\n                } else {\n                    currentRow.push(createNode(col, row));\n                }\n            }\n            grid.push(currentRow);\n        }\n        return grid;\n    }\n\n    getInitialGrid() {\n        const grid = [];\n        for (let row = 0; row < this.state.rows; row++) {\n            const currentRow = [];\n            for (let col = 0; col < this.state.cols; col++) {\n                currentRow.push(createNode(col, row));\n            }\n            grid.push(currentRow);\n        }\n        return grid;\n    }\n\n    render() {\n        let nodes = this.state.grid.map((row) => {\n            return (\n                <div className={\"grid-row\"}>\n                    {row.map((node) => {\n                        const {row, col, isFinish, isStart, isWall} = node;\n                        return (\n                            <GridNode row={row} col={col} isStart={isStart} isFinish={isFinish} isWall={isWall}\n                                      onMouseDown={() => this.handleMouseDown(row, col)}\n                                      onMouseEnter={() => this.handleMouseEnter(row, col)}\n                                      onTouchMove={() => this.handleMouseEnter(row, col)}\n                                      style={this.state.nodeStyle}\n                            />\n                        )\n                    })}\n                </div>\n            )\n        })\n        return (\n            <main className={\"main-sidebar\"} id={\"main\"}>\n                <div className={\"sidebar\"}>\n                    <div className={\"sidebar-settings\"}>\n                        <div className={\"sidebar-setting\"}>\n                            <p> Choose an algorithm </p>\n\n                            <div className={\"selection-dropdown\"} onClick={this.showAlgorithms}>\n                                <div className={\"current-option\"}>\n                                    <p> {this.state.algorithm} </p>\n                                </div>\n\n                                <div className={\"caret-down\"}>\n                                    <i className=\"fas fa-caret-down\" ref={this.dropdownCaret}> </i>\n                                </div>\n                            </div>\n                            <div className={\"selection-options\"} ref={this.dropdownSelection}>\n                                <ul>\n                                    {\n                                        options.map(option => (\n                                            <div onClick={() => this.changeAlgorithm(option)}\n                                                 key={option}> {option} </div>\n                                        ))\n                                    }\n                                </ul>\n                            </div>\n\n                            <button className={\"sidebar-button\"}\n                                    onClick={this.runAlgorithm}>\n                                Run\n                            </button>\n                        </div>\n\n                        <div className={\"sidebar-setting\"}>\n                            <p> Recursive Backtrack Maze </p>\n                            <button className={\"sidebar-button\"} onClick={() => this.recursiveDivision()}>\n                                Generate Maze\n                            </button>\n                        </div>\n                        <div className={\"sidebar-setting\"}>\n                            <p> Clear Grid </p>\n                            <button className={\"sidebar-button\"} onClick={() => this.clearGrid()}>\n                                Clear\n                            </button>\n                        </div>\n                    </div>\n                </div>\n\n                <div className={\"main-content\"} id={\"grid-wrapper\"} onMouseLeave={() => this.handleMouseLeave()}>\n                    <div id={\"grid\"}>\n                        {nodes}\n                    </div>\n                </div>\n            </main>\n        )\n    }\n}\n\nfunction createNode(col: number, row: number) {\n    return {\n        col: col,\n        row: row,\n        isStart: row === START_NODE_ROW && col === START_NODE_COL,\n        isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n        weight: Infinity,\n        isVisited: false,\n        isWall: false,\n        previousNode: null\n    } as Node;\n}\n\nexport default PathfindingVisualizer;\n\n","import React from 'react';\nimport './App.css';\nimport Header from \"./Layout/Header/Header\";\nimport Footer from \"./Layout/Footer/Footer\";\nimport Home from \"./Layout/Main/Home/Home\";\nimport Documentation from \"./Layout/Main/Documentation/Layout/Documentation\";\nimport {BrowserRouter as Router, Switch, Route} from \"react-router-dom\";\nimport SortingVisualizer from \"./Layout/Main/SortingVisualizer/SortingVisualizer\";\nimport PathfindingVisualizer from \"./Layout/Main/PathfindingVisualizer/PathfindingVisualizer\";\n\ntype Props = {};\ntype State = {};\n\nclass App extends React.Component<Props, State> {\n    constructor(props: Props) {\n        super(props);\n    }\n\n    render() {\n        return (\n            <Router>\n                <div id={\"app-wrapper\"}>\n                    <Header/>\n                    <Switch>\n                        <Route exact path=\"/AlgoVisual\">\n                            <Home/>\n                        </Route>\n\n                        <Route exact path=\"/AlgoVisual/sorting\">\n                            <SortingVisualizer/>\n                        </Route>\n\n                        <Route exact path=\"/AlgoVisual/pathfinding\">\n                            <PathfindingVisualizer/>\n                        </Route>\n\n                        <Route path=\"/AlgoVisual/documentation\">\n                            <Documentation/>\n                        </Route>\n\n                        <Route path=\"/AlgoVisual/about\">\n\n                        </Route>\n                    </Switch>\n                    <Footer/>\n                </div>\n            </Router>\n        )\n    }\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './AlgoVisual/App';\nimport reportWebVitals from './Misc/reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}