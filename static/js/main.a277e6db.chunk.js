(this["webpackJsonpalgo-visual"]=this["webpackJsonpalgo-visual"]||[]).push([[0],{173:function(e,t,n){},174:function(e,t,n){},183:function(e,t,n){},184:function(e,t,n){},185:function(e,t,n){},598:function(e,t,n){},599:function(e,t,n){},600:function(e,t,n){},601:function(e,t,n){},603:function(e,t,n){"use strict";n.r(t);var i=n(2),r=n.n(i),a=n(144),s=n.n(a),o=n(7),l=n(12),c=n(9),h=n(10),u=(n(173),n(17)),d=(n(174),n(14)),m=n(0),p=function(e){Object(c.a)(n,e);var t=Object(h.a)(n);function n(e){var r;return Object(o.a)(this,n),(r=t.call(this,e)).dropdownMenu=Object(i.createRef)(),r.dropdownCaret=Object(i.createRef)(),r.state={showAlgosMenu:!1},r.showAlgosMenu=r.showAlgosMenu.bind(Object(u.a)(r)),r.closeAlgosMenu=r.closeAlgosMenu.bind(Object(u.a)(r)),r.displayAlgosMenu=r.displayAlgosMenu.bind(Object(u.a)(r)),r}return Object(l.a)(n,[{key:"showAlgosMenu",value:function(e){var t=this;this.state.showAlgosMenu||(this.setState({showAlgosMenu:!0},(function(){return t.displayAlgosMenu()})),e.stopPropagation(),document.addEventListener("click",this.closeAlgosMenu))}},{key:"closeAlgosMenu",value:function(){var e=this;this.setState({showAlgosMenu:!1},(function(){return e.displayAlgosMenu()})),document.removeEventListener("click",this.closeAlgosMenu)}},{key:"displayAlgosMenu",value:function(){this.state.showAlgosMenu?(this.dropdownMenu.current.style.display="block",this.dropdownCaret.current.style.transform="rotate(180deg)",this.dropdownCaret.current.style.transition="all 300ms linear"):(this.dropdownMenu.current.style.display="none",this.dropdownCaret.current.style.transform="rotate(0deg)",this.dropdownCaret.current.style.transition="all 300ms linear")}},{key:"render",value:function(){return Object(m.jsxs)("header",{id:"header",children:[Object(m.jsx)("div",{id:"logo-wrapper",children:Object(m.jsx)(d.b,{to:"/AlgoVisual",children:Object(m.jsx)("p",{id:"name",children:" AlgoVisual "})})}),Object(m.jsx)("div",{id:"nav-wrapper",children:Object(m.jsx)("nav",{id:"nav-bar",children:Object(m.jsxs)("ul",{children:[Object(m.jsx)("li",{children:Object(m.jsxs)("div",{className:"nav-link",children:[Object(m.jsxs)("div",{className:"nav-option",onClick:this.showAlgosMenu,children:[Object(m.jsx)("p",{className:"noselect",children:" Algorithms "}),Object(m.jsx)("i",{className:"fas fa-caret-down",ref:this.dropdownCaret,children:" "})]}),Object(m.jsx)("div",{id:"dropdown",ref:this.dropdownMenu,children:Object(m.jsxs)("ul",{children:[Object(m.jsx)("li",{children:Object(m.jsx)(d.b,{to:"/AlgoVisual/sorting",className:"nav-link",children:Object(m.jsx)("div",{className:"algos-option",children:Object(m.jsx)("p",{children:" Sorting "})})})}),Object(m.jsx)("li",{children:Object(m.jsx)(d.b,{to:"/AlgoVisual/pathfinding",className:"nav-link",children:Object(m.jsx)("div",{className:"algos-option",children:Object(m.jsx)("p",{children:" Pathfinding "})})})}),Object(m.jsx)("li",{children:Object(m.jsx)(d.b,{to:"/AlgoVisual/datastructures",className:"nav-link",children:Object(m.jsx)("div",{className:"algos-option",children:Object(m.jsx)("p",{children:" Data Structures "})})})})]})})]})}),Object(m.jsx)("li",{children:Object(m.jsx)(d.b,{to:"/AlgoVisual/documentation",className:"nav-link",children:Object(m.jsx)("div",{className:"nav-option",children:Object(m.jsx)("p",{children:" Documentation "})})})}),Object(m.jsx)("li",{children:Object(m.jsx)(d.b,{to:"/AlgoVisual/about",className:"nav-link",children:Object(m.jsx)("div",{className:"nav-option",children:Object(m.jsx)("p",{children:" About "})})})})]})})})]})}}]),n}(r.a.Component),b=(n(183),function(e){Object(c.a)(n,e);var t=Object(h.a)(n);function n(e){return Object(o.a)(this,n),t.call(this,e)}return Object(l.a)(n,[{key:"render",value:function(){return Object(m.jsxs)("footer",{id:"footer",children:[Object(m.jsx)("p",{id:"footer-header",children:" Connect with me through these platforms "}),Object(m.jsx)("div",{id:"contact-wrapper",children:Object(m.jsxs)("ul",{children:[Object(m.jsx)("li",{children:Object(m.jsxs)("a",{href:"https://github.com/eduardo-vidals",target:"_blank",className:"social-link",children:[Object(m.jsx)("i",{className:"fab fa-github",children:" "}),Object(m.jsx)("span",{className:"social-text",children:" GitHub "})]})}),Object(m.jsx)("li",{children:Object(m.jsxs)("a",{href:"https://www.linkedin.com/in/eduardo-vidals",target:"blank",className:"social-link",children:[Object(m.jsx)("i",{className:"fab fa-linkedin-in",children:" "}),Object(m.jsx)("span",{className:"social-text",children:" LinkedIn "})]})}),Object(m.jsx)("li",{children:Object(m.jsxs)("a",{href:"https://www.instagram.com/eddy_the_professionalpenguin",target:"blank",className:"social-link",children:[Object(m.jsx)("i",{className:"fab fa-instagram",children:" "}),Object(m.jsx)("span",{className:"social-text",children:" Instagram "})]})}),Object(m.jsx)("li",{children:Object(m.jsxs)("a",{className:"social-link",children:[Object(m.jsx)("i",{className:"fab fa-discord",children:" "}),Object(m.jsx)("span",{className:"social-text",children:" Discord "})]})}),Object(m.jsx)("li",{children:Object(m.jsxs)("a",{className:"social-link",children:[Object(m.jsx)("i",{className:"fas fa-envelope",children:" "}),Object(m.jsx)("span",{className:"social-text",children:" Email "})]})})]})})]})}}]),n}(r.a.Component)),g=(n(184),function(e){Object(c.a)(n,e);var t=Object(h.a)(n);function n(e){return Object(o.a)(this,n),t.call(this,e)}return Object(l.a)(n,[{key:"render",value:function(){return Object(m.jsxs)("div",{id:"home-wrapper",children:[Object(m.jsx)("h1",{id:"home-header-text",children:" Visualizing made easy. "}),Object(m.jsx)("p",{id:"home-text",children:"This is my first big project, please feel free to explore the beautiful visualization of algorithms and data structures by clicking one of the buttons below."}),Object(m.jsxs)("div",{id:"buttons-menu",children:[Object(m.jsx)(d.b,{to:"/AlgoVisual/sorting",children:Object(m.jsx)("div",{className:"home-section",children:" Sorting Algorithms "})}),Object(m.jsx)(d.b,{to:"/AlgoVisual/pathfinding",children:Object(m.jsx)("div",{className:"home-section",children:" Pathfinding Algorithms "})}),Object(m.jsx)(d.b,{to:"/AlgoVisual/datastructures",children:Object(m.jsx)("div",{className:"home-section",children:" Data Structures "})})]})]})}}]),n}(r.a.Component)),j=(n(185),n(16)),f=n(163),v=n(24),x=n(162),y=n(155),w=n(621),O=n(160),S=n(161),k=n(146),A=["inline","className","children"],N=function(e){Object(c.a)(n,e);var t=Object(h.a)(n);function n(e){return Object(o.a)(this,n),t.call(this,e)}return Object(l.a)(n,[{key:"render",value:function(){return Object(m.jsx)(S.a,{children:this.props.markdown,remarkPlugins:[[x.a],[y.a]],components:{a:function(e){var t=Object.assign({},e);return Object(m.jsx)("a",Object(v.a)({target:"_blank"},t))},em:function(e){var t=Object.assign({},e);return t.children[0]&&"string"===typeof t.children[0]&&t.children[0].startsWith("$")?Object(m.jsx)(k.a,{tex:String(t.children[0].substring(1)),display:!1,setting:{internalSpeechTitles:!0}}):Object(m.jsx)("i",Object(v.a)({},t))},code:function(e){var t=e.inline,n=e.className,i=e.children,r=Object(f.a)(e,A),a=/language-(\w+)/.exec(n||"");return!t&&a?Object(m.jsx)(w.a,{children:String(i).replace(/\n$/,""),customStyle:{padding:"20px 30px 20px 0px"},style:O.a,showLineNumbers:!0,language:a[1],PreTag:"div"}):Object(m.jsx)("code",Object(v.a)(Object(v.a)({className:n},r),{},{children:i}))}}})}}]),n}(r.a.Component),T=function(e){Object(c.a)(n,e);var t=Object(h.a)(n);function n(e){return Object(o.a)(this,n),t.call(this,e)}return Object(l.a)(n,[{key:"componentDidMount",value:function(){this.props.section.current.style.borderLeft="10px white solid",this.props.section.current.style.backgroundColor="#29354b"}},{key:"componentWillUnmount",value:function(){null!==this.props.section.current&&(this.props.section.current.style.borderLeft="none",this.props.section.current.style.backgroundColor="inherit")}},{key:"render",value:function(){return Object(m.jsx)("div",{className:"documentation-wrapper",children:Object(m.jsx)("div",{className:"documentation",children:Object(m.jsx)("div",{className:"markdown",children:Object(m.jsx)(N,{markdown:"\n# Introduction \nThis part of the page will go over the implementations of the algorithms and data structures that are implemented throughout the site.\n\n- Before starting, this documentation page assumes that you have a good understanding of the Java programming language. \n- An explanation of the data structures and algorithms will be provided in their respective sections. \n \n## Inspiration & Credits\n- This project was largely inspired by Cl\xe9ment Mihailescu's sorting and pathfinding visualizer.\n- The algorithm and data structure implementations are inspired by the Coursera algorithm courses offered by Princeton University under Robert Sedgewick & Kevin Wayne. \n- Thanks to freeCodeCamp for the wonderful projects offered within their course which helped me build a solid foundation of the React framework. \n- The \n## Respective Links\n- [Cl\xe9ment Mihailescu's Sorting Visualizer](https://github.com/clementmihailescu/Sorting-Visualizer)\n- [Cl\xe9ment Mihailescu's Pathfinding Visualizer](https://github.com/clementmihailescu/Pathfinding-Visualizer)\n- [Algorithms Part I by Robert Sedgewick & Kevin Wayne](https://www.coursera.org/learn/algorithms-part1)\n- [Algorithms Part II by Robert Sedgewick & Kevin Wayne](https://www.coursera.org/learn/algorithms-part2)\n- [Front End Development Libraries by freeCodeCamp](https://www.freecodecamp.org/learn/front-end-development-libraries)\n"})})})})}}]),n}(r.a.Component),E=(n(598),{textDecoration:"none"}),C={listStyleType:"none",padding:"10px",margin:"10px 0",fontSize:"15px",borderRadius:"10px",cursor:"pointer",color:"black"},L={margin:"0 13px",height:"1px",backgroundColor:"#c5c5c5",border:"none",borderRadius:"5px"},M=function(e){Object(c.a)(n,e);var t=Object(h.a)(n);function n(e){return Object(o.a)(this,n),t.call(this,e)}return Object(l.a)(n,[{key:"dashify",value:function(e){return e.replace(/[^a-zA-Z0-9]+/g,"-").replace(/([A-Z]+)([A-Z][a-z])/g,"$1-$2").replace(/([a-z])([A-Z])/g,"$1-$2").replace(/([0-9])([^0-9])/g,"$1-$2").replace(/([^0-9])([0-9])/g,"$1-$2").replace(/-+/g,"-").toLowerCase()}},{key:"render",value:function(){var e=this,t=this.props.sections.map((function(t,n){return Object(m.jsxs)("div",{children:[Object(m.jsx)(d.b,{to:e.props.directory+"/"+e.dashify(t),style:E,children:e.props.sectionHighlight&&n===e.props.section-1?Object(m.jsxs)("li",{style:C,className:"active-section",children:[" ",++n,". ",t]},t):Object(m.jsxs)("li",{style:C,children:[" ",++n,". ",t]},t)}),n<e.props.sections.length?Object(m.jsx)("hr",{style:L}):null]})}));return Object(m.jsx)("div",{className:"sections-wrapper-wrapper",children:Object(m.jsx)("div",{className:"sections-wrapper",style:this.props.wrapperStyle,children:Object(m.jsxs)("div",{className:"sections",children:[Object(m.jsx)("p",{className:"sections-header",children:" In this part: "}),Object(m.jsx)("div",{className:"section-names",children:Object(m.jsx)("ul",{children:t})})]})})})}}]),n}(r.a.Component),I=["Time Complexity","ArrayList","LinkedList","Heaps","Binary Search Trees","Analysis of Data Structures"],V={width:"100%"},z=function(e){Object(c.a)(n,e);var t=Object(h.a)(n);function n(e){return Object(o.a)(this,n),t.call(this,e)}return Object(l.a)(n,[{key:"componentDidMount",value:function(){this.props.section.current.style.borderLeft="10px white solid",this.props.section.current.style.backgroundColor="#29354b"}},{key:"componentWillUnmount",value:function(){null!==this.props.section.current&&(this.props.section.current.style.borderLeft="none",this.props.section.current.style.backgroundColor="inherit")}},{key:"render",value:function(){return Object(m.jsx)("div",{className:"documentation-wrapper",children:Object(m.jsxs)("div",{className:"documentation",children:[Object(m.jsx)("div",{className:"markdown",children:Object(m.jsx)(N,{markdown:"\n# Data Structures\nThis part of the page will go over the many relevant data strucures that are implemented throughout the site. \n"})}),Object(m.jsx)(M,{wrapperStyle:V,sectionHighlight:!1,sections:I,directory:"/AlgoVisual/documentation/data-structures"})]})})}}]),n}(r.a.Component),D=["Bubble Sort","Insertion Sort","Selection Sort","Merge Sort","Quick Sort","Heap Sort","Analysis of Sorting Algorithms"],B={width:"100%"},R=function(e){Object(c.a)(n,e);var t=Object(h.a)(n);function n(e){return Object(o.a)(this,n),t.call(this,e)}return Object(l.a)(n,[{key:"componentDidMount",value:function(){this.props.section.current.style.borderLeft="10px white solid",this.props.section.current.style.backgroundColor="#29354b"}},{key:"componentWillUnmount",value:function(){null!==this.props.section.current&&(this.props.section.current.style.borderLeft="none",this.props.section.current.style.backgroundColor="inherit")}},{key:"render",value:function(){return Object(m.jsx)("div",{className:"documentation-wrapper",children:Object(m.jsxs)("div",{className:"documentation",children:[Object(m.jsx)("div",{className:"markdown",children:Object(m.jsx)(N,{markdown:"\n# Sorting Algorithms\nThis part of the page will go over the many relevant sorting algorithms that are implemented throughout the site. \n"})}),Object(m.jsx)(M,{wrapperStyle:B,sections:D,directory:"/AlgoVisual/documentation/sorting",sectionHighlight:!1})]})})}}]),n}(r.a.Component),$=function(e){Object(c.a)(n,e);var t=Object(h.a)(n);function n(e){return Object(o.a)(this,n),t.call(this,e)}return Object(l.a)(n,[{key:"componentDidMount",value:function(){this.props.section.current.style.borderLeft="10px white solid",this.props.section.current.style.backgroundColor="#29354b"}},{key:"componentWillUnmount",value:function(){null!==this.props.section.current&&(this.props.section.current.style.borderLeft="none",this.props.section.current.style.backgroundColor="inherit")}},{key:"render",value:function(){return Object(m.jsx)("div",{})}}]),n}(r.a.Component);var W=Object(j.f)((function(e){var t=e.history;return Object(i.useEffect)((function(){var e=t.listen((function(){window.scrollTo(0,0)}));return function(){e()}}),[]),null})),H=(n(599),{marginTop:"20px"}),F={margin:"15px 0",display:"flex",padding:"10px 5px",borderRadius:"5px",color:"black"},q={marginLeft:"10px",fontSize:"15px"},Q={textDecoration:"none"},P=function(e){Object(c.a)(n,e);var t=Object(h.a)(n);function n(e){return Object(o.a)(this,n),t.call(this,e)}return Object(l.a)(n,[{key:"render",value:function(){return Object(m.jsxs)("div",{className:"next-section-wrapper",children:[Object(m.jsx)("p",{style:H,children:" You have reacted the end of this section! Continue to the next section: "}),Object(m.jsx)(d.b,{to:this.props.directory,style:Q,children:Object(m.jsxs)("div",{className:"next-section",style:F,children:[Object(m.jsx)("i",{className:"fas fa-arrow-right"}),Object(m.jsxs)("p",{style:q,children:[" ",this.props.sectionName," "]})]})})]})}}]),n}(r.a.Component),G={margin:"20px 0"},U={width:"400px"},_=function(e){Object(c.a)(n,e);var t=Object(h.a)(n);function n(e){return Object(o.a)(this,n),t.call(this,e)}return Object(l.a)(n,[{key:"componentDidMount",value:function(){this.props.section.current.style.borderLeft="10px white solid",this.props.section.current.style.backgroundColor="#29354b"}},{key:"componentWillUnmount",value:function(){null!==this.props.section.current&&(this.props.section.current.style.borderLeft="none",this.props.section.current.style.backgroundColor="inherit")}},{key:"render",value:function(){return Object(m.jsx)("div",{className:"documentation-wrapper",children:Object(m.jsxs)("div",{className:"documentation",children:[Object(m.jsx)("div",{className:"markdown",children:Object(m.jsx)(N,{markdown:this.props.markdown})}),this.props.nextSection?Object(m.jsx)(P,{directory:this.props.nextSectionDirectory,sectionName:this.props.nextSectionName}):Object(m.jsx)("p",{style:G,children:" You have reached the end of the section!"}),Object(m.jsx)(M,{wrapperStyle:U,sections:this.props.sections,directory:this.props.mainDirectory,sectionHighlight:!0,section:this.props.partNumber})]})})}}]),n}(r.a.Component),J=(n(600),["Time Complexity","ArrayList","LinkedList","Heaps","Binary Search Trees","Analysis of Data Structures"]),K=["Bubble Sort","Insertion Sort","Selection Sort","Merge Sort","Quick Sort","Heap Sort","Analysis of Sorting Algorithms"],Y=function(e){Object(c.a)(n,e);var t=Object(h.a)(n);function n(e){var r;return Object(o.a)(this,n),(r=t.call(this,e)).gettingStartedSection=Object(i.createRef)(),r.dataStructuresSection=Object(i.createRef)(),r.sortingSection=Object(i.createRef)(),r.pathfindingSection=Object(i.createRef)(),r}return Object(l.a)(n,[{key:"render",value:function(){return Object(m.jsxs)("main",{className:"main-sidebar",children:[Object(m.jsx)("div",{className:"sidebar",children:Object(m.jsxs)("div",{id:"documentation-section",children:[Object(m.jsx)(d.b,{to:"/AlgoVisual/documentation",className:"documentation-link",children:Object(m.jsx)("div",{className:"section",ref:this.gettingStartedSection,children:Object(m.jsx)("p",{children:" Introduction "})})}),Object(m.jsx)(d.b,{to:"/AlgoVisual/documentation/data-structures",className:"documentation-link",children:Object(m.jsx)("div",{className:"section",ref:this.dataStructuresSection,children:Object(m.jsx)("p",{children:" Data Structures "})})}),Object(m.jsx)(d.b,{to:"/AlgoVisual/documentation/sorting",className:"documentation-link",children:Object(m.jsx)("div",{className:"section",ref:this.sortingSection,children:Object(m.jsx)("p",{children:" Sorting "})})}),Object(m.jsx)(d.b,{to:"/AlgoVisual/documentation/pathfinding",className:"documentation-link",children:Object(m.jsx)("div",{className:"section",ref:this.pathfindingSection,children:Object(m.jsx)("p",{children:" Pathfinding "})})})]})}),Object(m.jsx)(W,{}),Object(m.jsxs)(j.c,{children:[Object(m.jsx)(j.a,{exact:!0,path:"/AlgoVisual/documentation",children:Object(m.jsx)(T,{section:this.gettingStartedSection})}),Object(m.jsx)(j.a,{exact:!0,path:"/AlgoVisual/documentation/data-structures",children:Object(m.jsx)(z,{section:this.dataStructuresSection})}),Object(m.jsx)(j.a,{exact:!0,path:"/AlgoVisual/documentation/data-structures/time-complexity",children:Object(m.jsx)(_,{mainDirectory:"/AlgoVisual/documentation/data-structures",sections:J,partNumber:1,markdown:'\n# Time Complexity\nThis section will go over time complexity.\n\n## Brief Explanation\nTime complexity can be defined as the **asymptomatic** behavior of the graph. In simpler terms, as the size of the function gets progressively larger, we can put functions in the same asymptomatic category. For example, let\'s say we have the following functions: *$f(x) = 100n* and *$g(x) = n*. As *$n* gets larger, both functions become categorized under the same asymptomatic bound because the difference becomes negligible as *$n* gets larger. \n\n## Big-O Notation\nTo categorize the asymptomatic bound of an algorithm, we use Big-O notation. For example, Bubble Sort has a **worst-case** of *$O(n^2)*, which is pronounced as "Big O of *$n^2*." This algorithm will be explained in the sorting section of the documentation page.  \n\n## Graph Representation\nHere is a representation of the asymptomatic bounds used when regarding data structures and algorithms. \n![Time Complexity Graph](https://he-s3.s3.amazonaws.com/media/uploads/ece920b.png)\n\n## Importance\nTime complexity is an important concept to grasp right away, as we will be analyzing the time complexity of the data structures and algorithms that will be implemented throughout the site. Click below to go to the next section. \n',section:this.dataStructuresSection,nextSectionDirectory:"/AlgoVisual/documentation/data-structures/array-list",nextSection:!0,nextSectionName:"2. ArrayList"})}),Object(m.jsx)(j.a,{exact:!0,path:"/AlgoVisual/documentation/data-structures/array-list",children:Object(m.jsx)(_,{mainDirectory:"/AlgoVisual/documentation/data-structures",sections:J,partNumber:2,markdown:"\n# ArrayList in Java\nThis section will go over a simple implementation of ArrayList.\n\n## Arrays\nAs a reminder, keep in mind that arrays have a limited size in the amount of data they can hold. However, in an ArrayList we are able to manipulate arrays in such a way that allows us to insert and remove elements without having to worry about a limited size. \n\n## ArrayList Implementation\nKeeping the last section in mind, let's initialize our instance variables for our ArrayList. We will be using generics for our implementation to easily apply our ArrayList across all objects. \n\n```java\npublic class ArrayList<E> implements Iterable<E> {\n    private static final int INIT_CAPACITY = 8; // initial capacity of array\n    private E[] arr; \n    private int n; // size of array\n    \n    public ArrayList(){\n        arr = (E[]) new Object[INIT_CAPACITY]; // generic array \n        n = 0;\n    }\n}\n```\n\n### Relevant Methods\nFirst, let's implement the straightforward methods of a list.\n```java\npublic boolean isEmpty() {\n    return n == 0;\n}\n\npublic int size() {\n    return n;\n}\n```\n\n### Helper Method (Resizing Array)\nLet's now implement our first relevant helper method for an ArrayList. We will need a resize method that will use an array with a new capacity and copies all values from the old array into this new array with an updated capacity. \n\n```java\nprivate void resize(int capacity) {\n    E[] copy = (E[]) new Object[capacity];\n    for (int i = 0; i < n; i++){\n        copy[i]= arr[i];\n    }\n    arr = copy;\n}\n```\n\n### Instance Methods\nWith the help of the previous helper method, we are now able to implement our add and remove methods. \n\n```java\npublic void add(E item){\n    // resize once we reach max capacity\n    if (n == arr.length) {\n        // resizing by 2x ensures we don't resize too frequently and don't allocate too much memory\n        resize(arr.length * 2);\n    }\n    arr[n++] = item;\n}\n\npublic E remove(int index){\n    E removed = arr[index];\n    int numMoved = n - index - i; // numOfNumbers that need to be moved\n    System.arraycopy(arr, index + 1, arr, index, numMoved); // shifts elements to left by 1\n    arr[n--] = null; // decrement size and ensure last arr value is null \n    \n    // resize to ensure you don't allocate too much memory when you have a few amount of elements\n    if (n > 0 && n == arr.length / 4){\n        resize(arr.length / 2);\n    }\n    return removed;\n}\n```\n\n### Iterator\nAs a reminder, remember to implement the Iterator interface and implement the following methods: \n- hasNext()\n    - returns true or false depending on whether there is a next element\n- next()\n    - returns the next element in the iterator\n- remove()\n    - allows you to remove elements while traversing\n\nWe will implement an iterator to allow users to remove elements while the list is being traversed. Iterators also allow you to use the for-each syntax for easier traversal. \n\n```java\npublic Iterator<E> iterator() {\n    return new ListIterator();\n}\n\nprivate class ListIterator implements Iterator<E> {\n    private int i; // current index\n    \n    @Override\n    public boolean hasNext(){\n        return i < n;\n    }\n    \n    @Override\n    public E next(){\n        if (!hasNext()){\n            throw new NoSuchElementException();\n        }\n        return copy[i++];\n    }\n    \n    @Override \n    public void remove() {\n        if (i == 0) {\n            throw new IllegalStateException();\n        }\n        ArrayList.this.remove(--i);\n    }\n}\n```\n\n\n## Visualizer\n...And that's it! Our implementation of ArrayList should be working just fine. Remember, there is also a simple visualization tool of how the array operates in an ArrayList. Click the button below to check out the visualizer!\n",section:this.dataStructuresSection,nextSectionDirectory:"/AlgoVisual/documentation/data-structures/linked-list",nextSection:!0,nextSectionName:"3. LinkedList"})}),Object(m.jsx)(j.a,{exact:!0,path:"/AlgoVisual/documentation/data-structures/linked-list",children:Object(m.jsx)(_,{mainDirectory:"/AlgoVisual/documentation/data-structures",sections:J,partNumber:3,markdown:"\n# LinkedList in Java\nThis section will go over a simple implementation of ArrayList.\n\n## Objects & Classes\nThere is sometimes confusion when linked lists are introduced due to not understanding the concept of objects and classes. Therefore, it is important that you understand the idea of having a **inner** class within a class. The idea of a Linked List is that an inner class can essentially act as a *pointer* that keeps track of **previous** and **next** nodes. This idea is explained in the image below. \n\n[TO DO IMAGE]\n\n## LinkedList Implementation\nKeeping the logic of the last section in mind, we can now initialize the barebones logic of a LinkedList. We will be using generics for our implementation to easily apply our LinkedList across all objects.\n\n```java\npublic class LinkedList<E> implements Iterable<E> {\n    private Node head; // first element in list\n    private Node tail; // last element in list\n    private int n; // size of arr\n    \n    private class Node {\n        Node next; // represents the node next to this current node\n        Node prev; // represents the node prev to this current node\n        E data; // represents the data within the current node\n        \n        public Node(E data){\n            this.data = data;\n        }\n    }     \n}\n```\n\nThe code above is the barebones logic of a **doubly-linked list.** It will have **two** pointers, one pointer to the previous element and one pointer to the next element. A **singly-linked list** only has **one** pointer that points to the next element. We will be implementing a doubly-linked list as it is more efficient and it'll be easier to understand a singly-linked list after implementing a doubly-linked list.\n\n### Relevant Methods\nFirst, let's implement the straightforward methods of a list.\n```java\npublic int size(){ \n    return n;\n}\n\npublic boolean isEmpty(){\n    return n == 0;\n}\n```\n\n\n### Stacks (LIFO)\nLet's introduce the concept of a **stack** as it serves as an important concept in computer science. A **stack** data structure works as **Last In, First Out (LIFO).** An analogy for this data structure is to imagine a pile of pancakes. Which pancake is the first one to be removed? The last pancake that was put into the pile will most likely result in it being the first one removed. This concept is easily explained by the image below.\n\n[TO DO IMAGE]\n\nWe can now implement the relevant methods of a LinkedList that serve the purpose of a **stack** data structure. We will name the methods **addLast()** and **removeLast()**, but these methods can also be represented as **push()** and **pop().**\n\n```java\npublic void addLast(E data){\n    // save the \"oldTail\" in a temp variable (as this will become the old tail)\n    Node oldTail = tail;\n    // initialize new tail with new data, prev Node will always be the oldTail\n    tail = new Node(data);\n    tail.prev = oldTail;\n    // when we first add into our list, the head will be equal to the tail\n    if(isEmpty()){\n        head = tail;\n    } \n    // after that, the next value of the old tail will be the current tail\n    else {\n        oldTail.next = tail;\n    }\n    n++;\n}\n\npublic E removeLast(){\n    // throw an exception if element is being removed when list is empty\n    if (isEmpty()) {\n        throw new NoSuchElementException();\n    }  \n    // make a variable for the old tail so we can return the data when the element is removed\n    Node oldTail = tail;\n    // make new tail be equal to the prev node of the tail\n    // then make the next value null for garbage collection\n    if (size() > 1){\n        tail = tail.prev;\n        tail.next = null;  \n    }\n    // this essentially means the list is empty so make both values null\n    else {\n        head = null;\n        tail = null;\n    }\n    n--;\n    return oldTail.data;\n}\n```\n\n### Queues (LIFO)\nLet's introduce the concept of a **queue** as it serves as an important concept in computer science. A **queue** data structure works as **First In, First Out (FIFO).** An analogy for a queue is to imagine being the first person in line for Subway, eventually, you will be the first one out of line and will go about your day and enjoy your subway sandwich! This concept is easily explained by the image below. \n\n[TO DO IMAGE]\n\nWe can now implement the relevant methods of a LinkedList that serve the purpose of a **queue** data structure. We will name the methods **addFirst()** and **removeFirst()**, but these methods can also be represented as **enqueue()** and **dequeue().**\n\n```java\npublic void addFirst(E data){\n    // save the \"oldHead\" in a temp variable (as this will become the old head)\n    Node oldHead = head;\n    // initialize new head with new data, next Node will always be the oldHead\n    head = new Node(data);\n    head.next = oldHead;\n    // when we first add into our list, the tail will be equal to the head\n    if (isEmpty()){\n        tail = head;\n    } \n    // after that, the prev value of the old head will be the current head\n    else {\n        oldHead.prev = head;\n    }\n    n++;\n}\n\npublic E removeFirst(){\n    // throw an exception if element is being removed when list is empty\n    if (isEmpty()) {\n        throw new NoSuchElementException();\n    } \n    // make a variable for the old head so we can return the data when the element is removed\n    Node oldHead = head;\n    // make new head be equal to the next node of the head\n    // then make the prev value null for garbage collection\n    if (size() > 1){\n        head = head.next;\n        head.prev = null;\n    } \n    // this essentially means the list is empty so make both values null\n    else {\n        head = null;\n        tail = null;\n    }\n    n--;\n    return oldHead.data;\n}\n```\n\n### Deque\nA **deque** is simply a combination of a stack and queue data structure. As a result, our LinkedList can be defined as deque data structure as it supports the operations of a stack and queue data structure.\n\n### Iterator\nLet's now implement an iterator for our LinkedList.\n```java\npublic Iterator<E> iterator() {\n    return new LinkedIterator();\n}\n\nprivate class LinkedIterator implements Iterator<E> {\n    // keep track of current and lastAccessed nodes\n    private Node current = head;\n    private Node lastAccessed = null;\n\n    @Override\n    public boolean hasNext() {\n        return current != null;\n    }\n\n    @Override\n    public E next() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        // update lastAccessed node since it will be used to remove the lastAccessed element\n        // since the current element always updates when next() is called, thus it cannot\n        // be used within remove()\n        lastAccessed = current;\n        E data = current.data;\n        current = current.next;\n        return data;\n    }\n\n    @Override\n    public void remove() {\n        if (lastAccessed == null) {\n            throw new IllegalStateException();\n        }\n        if (lastAccessed == head) {\n            LinkedList.this.removeFirst();\n        } else if (lastAccessed == tail) {\n            LinkedList.this.removeLast();\n        } \n        // update the prev and next pointers of the lastAccessed node\n        // make the lastAccessed node null for garbage collection\n        else {\n            Node prev = lastAccessed.prev;\n            Node next = lastAccessed.next;\n            prev.next = next;\n            next.prev = prev;\n            n--;\n            lastAccessed = null;\n        }\n    }        \n}\n```\n\nThe **remove()** method might be a bit hard to understand so images will be provided for each case.\n\n[TO DO IMAGE] (removeFirst)\n[TO DO IMAGE] (removeLast)\n[TO DO IMAGE] (otherCases)\n\n## Visualizer\n...And that's it! Our implementation of a LinkedList should be working just fine. Remember, there is also a visualization tool of how the pointers operate in a LinkedList. Click the button below to check out the visualizer!\n",section:this.dataStructuresSection,nextSectionDirectory:"/AlgoVisual/documentation/data-structures/heaps",nextSection:!0,nextSectionName:"4. Heaps"})}),Object(m.jsx)(j.a,{exact:!0,path:"/AlgoVisual/documentation/data-structures/heaps",children:Object(m.jsx)(_,{mainDirectory:"/AlgoVisual/documentation/data-structures",sections:J,partNumber:4,markdown:"\n# Heaps\n",section:this.dataStructuresSection,nextSectionDirectory:"/AlgoVisual/documentation/data-structures/binary-search-trees",nextSection:!0,nextSectionName:"5. Binary Search Trees"})}),Object(m.jsx)(j.a,{exact:!0,path:"/AlgoVisual/documentation/data-structures/binary-search-trees",children:Object(m.jsx)(_,{mainDirectory:"/AlgoVisual/documentation/data-structures",sections:J,partNumber:5,markdown:"\n# Binary Search Trees\n",section:this.dataStructuresSection,nextSectionDirectory:"/AlgoVisual/documentation/data-structures/analysis-of-data-structures",nextSection:!0,nextSectionName:"6. Analysis of Data Structures"})}),Object(m.jsx)(j.a,{exact:!0,path:"/AlgoVisual/documentation/data-structures/analysis-of-data-structures",children:Object(m.jsx)(_,{mainDirectory:"/AlgoVisual/documentation/data-structures",sections:J,partNumber:6,markdown:"\n# Analysis of Data Structures\n",section:this.dataStructuresSection,nextSection:!1})}),Object(m.jsx)(j.a,{exact:!0,path:"/AlgoVisual/documentation/sorting",children:Object(m.jsx)(R,{section:this.sortingSection})}),Object(m.jsx)(j.a,{exact:!0,path:"/AlgoVisual/documentation/sorting/bubble-sort",children:Object(m.jsx)(_,{mainDirectory:"/AlgoVisual/documentation/sorting",sections:K,partNumber:1,markdown:"\n# Bubble Sort\nThis section will go over an implementation of Bubble Sort.\n\n## Bubble Sort Implementation\nWe will be using generics for our implementation to easily apply our sorting algorithm across all types of arrays.\n\n### Rationale\nThe basis of Bubble Sort is to swap elements if the current element is greater than the element ahead.\n\n### Helper Method\nWe will be using the following **swap()** helper method to swap values from the array.\n```java\nprivate static <E> void swap(E[] arr, int i, int j){\n    E temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n```\n\n### Sorting Algorithm\nThis is the setup used for Bubble Sort.\n\n```java\n// <E extends Comparable> just means that E (the data type of the array) must\n// implement the Comparable interface, <? super E> means that E itself or the\n// super class can implement Comparable\npublic static <E extends Comparable<? super E>> void sort(E[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n        for (int j = 0; j < arr.length - 1 - i; j++) {\n            // compare elements from indices j and j + 1, swap if j > j + 1\n            if (arr[j].compareTo(arr[j + 1]) > 0){\n                swap(arr, j, j + 1);\n            }\n        }\n    }\n}\n```\n\n## Time Complexity (Analysis)\nBubble Sort is a **stable** sorting algorithm but it is often regarded as the **worst** sorting algorithm.\n- The best case can be *$O(n)*, but this implementation has a best case of *$O(n^2)*\n- The average case is *$O(n^2)*\n- The worst case is *$O(n^2)*\n\n\n## Visualizer\n...And that's it! Our implementation of Bubble Sort should be working just fine. Remember, there is also a simple visualization tool for sorting algorithms. Click the button below to check out the visualizer!\n",section:this.sortingSection,nextSectionDirectory:"/AlgoVisual/documentation/sorting/insertion-sort",nextSection:!0,nextSectionName:"2. Insertion Sort"})}),Object(m.jsx)(j.a,{exact:!0,path:"/AlgoVisual/documentation/sorting/insertion-sort",children:Object(m.jsx)(_,{mainDirectory:"/AlgoVisual/documentation/sorting",sections:K,partNumber:2,markdown:"\n# Insertion Sort\nThis section will go over an implementation of Insertion Sort.\n\n## Insertion Sort Implementation \nWe will be using generics for our implementation to easily apply our sorting algorithm across all types of arrays.\n\n### Rationale\nThe basis of Insertion Sort is to swap until there isn't an element greater than the key. This process starts with index one as the key and progressively increments until the array is fully sorted.\n\n### Sorting Algorithm\n```java\npublic static void <E extends Comparable<? super E>> sort(E[] arr){\n    for (int i = 1; i < arr.length; i++){\n        // keep track of the key for the last swap\n        T key = arr[i];\n        // starting index will always be one below i\n        int j = i - 1;\n        // if the val to the left is bigger, then replace it\n        while(j >= 0 && arr[j].compareTo(key) > 0){\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        // we can replace arr[j + 1] with the key since that is the last swap we need to do\n        arr[j + 1] = key;\n    }\n}\n```\n\n## Time Complexity (Analysis)\nInsertion Sort is a **stable** sorting algorithm and better than Bubble Sort. However, the worst case is still *$O(n^2)*\n- The best case is *$O(n)*\n- The average case is *$O(n^2)*\n- The worst case is *$O(n^2)*\n\n## Visualizer\n...And that's it! Our implementation of Bubble Sort should be working just fine. Remember, there is also a simple visualization tool for sorting algorithms. Click the button below to check out the visualizer!\n",section:this.sortingSection,nextSectionDirectory:"/AlgoVisual/documentation/sorting/selection-sort",nextSection:!0,nextSectionName:"3. Selection Sort"})}),Object(m.jsx)(j.a,{exact:!0,path:"/AlgoVisual/documentation/sorting/selection-sort",children:Object(m.jsx)(_,{mainDirectory:"/AlgoVisual/documentation/sorting",sections:K,partNumber:3,markdown:"\n# Selection Sort\nThis section will go over an implementation of Selection Sort.\n\n## Selection Sort Implementation\nWe will be using generics for our implementation to easily apply our sorting algorithm across all types of arrays.\n\n### Rationale\nThe basis of Selection Sort is to find the minimum element in the array and replace it with the current index of the outer loop. The inner loop start index increments after each iteration in the outer loop. (This allows us to ignore already sorted elements.)\n\n### Helper Method\nWe will be using the following **swap()** helper method to swap values from the array.\n```java\npublic static <E> void swap(E[] arr, int i, int j){\n    E temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n```\n\n### Sorting Algorithm\nThis is the setup used for Selection Sort. \n\n```java\npublic static <E extends Comparable<? super E> sort(E[] arr){\n    for (int i = 0; i < arr.length; i++){\n        // get min value and its index (we're only aware of 1 value so this is our min)\n        T min = arr[i];\n        int minIndex = i;\n        // start loop from i since any previous element will already be sorted\n        for (int j = i; j < arr.length; j++){\n            // if there's a new min, then update it\n            if (min.compareTo(arr[j] > 0){\n                min = arr[j];\n                minIndex = j;\n            }\n        }\n        // once you're at the end of the loop, swap the index of the smallest element with i \n        // this will put the lowest element at the start of our array\n        swap(arr, i, minIndex);\n    }\n}\n```\n\n## Time Complexity (Analysis)\nSelection Sort is an **unstable** sorting algorithm and better than Bubble Sort. However, the worst case is still *$O(n^2)*\n- The best case is *$O(n^2)*\n- The average case is *$O(n^2)*\n- The worst case is *$O(n^2)*\n\n## Visualizer\n...And that's it! Our implementation of Insertion Sort should be working just fine. Remember, there is also a simple visualization tool for sorting algorithms. Click the button below to check out the visualizer!\n",section:this.sortingSection,nextSectionDirectory:"/AlgoVisual/documentation/sorting/merge-sort",nextSection:!0,nextSectionName:"4. Merge Sort"})}),Object(m.jsx)(j.a,{exact:!0,path:"/AlgoVisual/documentation/sorting/merge-sort",children:Object(m.jsx)(_,{mainDirectory:"/AlgoVisual/documentation/sorting",sections:K,partNumber:4,markdown:"\n# Merge Sort\nThis section will go over **two** versions of Merge Sort because it will show the importance in creating efficient algorithms. \n\n## Merge Sort Implementation (Version 1)\nWe will be using generics for our implementation to easily apply our sorting algorithm across all types of arrays.\n\n### Rationale\nThe basis of Merge Sort is to think of one element by itself already being **sorted**. If we have **two elements** and **merge** them, then we will have 2 elements sorted. To accomplish this we recursively call the sorting method until we only have one element. Eventually, the recursive function will be at a point where we have **two** elements. Ultimately, we use the merge function for these pair of elements and this process continues until the array is fully sorted.\n\n### Helper Method\nWe will be using the following **merge()** helper method to **merge** two arrays that are **already sorted.**\n```java\nprivate static <E extends Comparable<? super E> void merge(E[] arr, int l, int m, int r){\n    int nL = m - l + 1; // size of left aux array\n    int nR = r - m; // size of right aux array\n    \n    E[] L = (E[]) new Comparable[nL];\n    E[] R = (E[]) new Comparable[nR];\n   \n    // initialize left aux array with the values from the main array\n    for (int i = 0; i < nL; i++){\n        L[i] = arr[l + i];\n    }\n    \n    // initialize right aux array with the values from the main array\n    for (int j = 0; j < nR; j++){\n        R[j] = arr[m + j + 1];\n    }\n    \n    int i = 0; // starting index of left aux arr\n    int j = 0; // starting index of right aux arr\n    int k = l; // starting index of main arr\n    \n    while (i < nL && j < nR){\n        // compare values from both aux arrays, determine which element is lower, then update\n        // the main arr with the lowest value, then increment indices as needed\n        if (L[i].compareTo(R[j]) <= 0){\n            arr[k] = L[i++]\n        } else {\n            arr[k] = R[j++];\n        }\n        k++;\n    }\n    \n    // update main arr with remaining elements from the left aux arr\n    while (i < nL){\n        arr[k] = L[i++];\n        k++;\n    }\n    \n    // update main arr with remaining elements from the right aux arr\n    while (j < nR){\n        arr[k] = R[j++];\n        k++;\n    }\n}\n```\n\n### Sorting Algorithm\nThis is the setup used for Merge Sort. \n\n```java\npublic static <E extends Comparable<? super E> void sort(E[] arr){\n    sort(arr, 0, arr.length - 1);\n}\nprivate static <E extends Comparable<? super E> void sort(E[] arr, int l, int r){ \n    if (l < r){\n        int m = (l + r)/2; // middle index\n        sort(arr, l, m); // left side of array\n        sort(arr, m + 1, r); // right side of array\n        merge(arr, l, m, r); // merge\n    }\n}\n```\n\n### Time Complexity & Space Complexity (Analysis)\nMerge Sort is a **stable** sorting algorithm and it is the first efficient sorting algorithm that will be covered.\n- The best case is *$O(nlogn)*\n- The average case is *$O(nlogn)*\n- The worst case is *$O(nlogn)*\n\nIt also uses an **auxilary** array in **merge()**, as a result, this algorithm has a space complexity of *$O(n).*\n\n## Merge Sort Implementation (Version 2)\nThis second version of Merge Sort will be more efficient than the previous one. It will only be creating the auxilary array **once** instead of creating multiple auxilary arrays as in the previous implementation. Therefore, this version of Merge Sort is more efficient.\n\n### Sort Method\nThis will be the updated version of **sort()** that only relies on one auxilary array.\n```java\npublic static <E extends Comparable<? super E>> void sort(E[] arr) {\n    E[] aux = arr.clone();\n    sort(arr, 0, arr.length - 1, aux);\n}\nprivate static <E extends Comparable<? super E>> void sort(E[] arr, int l, int r, E[] aux) {\n    if (l < r) {\n        int m = (l + r) / 2;\n        sort(aux, l, m, arr);\n        sort(aux, m + 1, r, arr);\n        merge(arr, l, m, r, aux);\n    }\n}\n```\n\n### Merge Method\nThis will be the updated version of **merge()** that only relies on one auxilary array.\n```java\nprivate static <E extends Comparable<? super E>> void merge(E[] arr, int l, int m, int r, E[] aux) {\n    int k = l, i = l;\n    int j = m + 1;\n    while (i <= m && j <= r) {\n        if (aux[i].compareTo(aux[j]) <= 0) {\n            arr[k++] = aux[i++];\n        } else {\n            arr[k++] = aux[j++];\n        }\n    }\n    while (i <= m) {\n        arr[k++] = aux[i++];\n    }\n    while (j <= r) {\n        arr[k++] = aux[j++];\n    }\n}\n```\n\n### Time Complexity & Space Complexity (Analysis)\nThis version of Merge Sort is still a **stable** sorting algorithm.\n- The best case is *$O(nlogn)*\n- The average case is *$O(nlogn)*\n- The worst case is *$O(nlogn)*\n\nThis algorithm has a space complexity of *$O(n)*, but it is more efficient as we only clone the auxilary array once. \n\n## Visualizer\n...And that's it! Our implementation of Merge Sort should be working just fine. Remember, there is also a simple visualization tool for sorting algorithms. Click the button below to check out the visualizer!\n",section:this.sortingSection,nextSectionDirectory:"/AlgoVisual/documentation/sorting/quick-sort",nextSection:!0,nextSectionName:"5. Quick Sort"})}),Object(m.jsx)(j.a,{exact:!0,path:"/AlgoVisual/documentation/sorting/quick-sort",children:Object(m.jsx)(_,{mainDirectory:"/AlgoVisual/documentation/sorting",sections:K,partNumber:5,markdown:"\n# Quick Sort\nThis section will go over **two** versions of Quick Sort because it will show the importance in creating efficient algorithms.\n\n## Quick Sort Implementation (Version 1)\nWe will be using generics for our implementation to easily apply our sorting algorithm across all types of arrays.\n\n### Rationale\nThe basis of Quick Sort is to pick an element from the list and to put all elements less than the pivot to the **left** and all elements greater the pivot to the **right.** As a result, we end up finding the **pivot**, which results in that element being **sorted.** This process is known as **partitioning** and we will be implementing it as a helper method. \n\n### Helper Method \nWe will be using the following **swap()** and **partition()** helper method to find the **pivot.**\n```java\nprivate static <E extends Comparable<? super E>> int partition(E[] arr, int l, int h){\n    E pivot = arr[l]; // we will be using the lowest element given as the pivot\n    int i = l - 1; // start index\n    int j = h + 1; // end index\n    while (true){\n        // increment i every time arr[i] is less than the value of the pivot\n        do {\n            i++;\n        } while(arr[i].compareTo(pivot) < 0);\n    \n        // increment j every time arr[j] is greater than the pivot\n        do {\n            j--;\n        } while(arr[j].compareTo(pivot) > 0);\n\n        // return pivot index once i >= j\n        if (i >= j){\n            return j;\n        }\n        \n        // swap once you find a value less than pivot and a value greater than pivot\n        swap(arr, i, j);\n    }\n}\n\nprivate static <E> void swap(E[] arr, int i, int j){\n    E temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n```\n\n\n### Sorting Algorithm\nThis is the setup used for Quick Sort. \n\n```java\npublic static <E extends Comparable<? super E>> void sort(E[] arr){\n    sort(arr, 0, arr.length - 1);\n}\n\nprivate static <E extends Comparable<? super E>> void sort(E[] arr, int l, int h){\n    if (l < h){\n        int pivot = partition(arr, l, h);\n        sort(arr, l, pivot);\n        sort(arr, pivot + 1, h);\n    }\n}\n```\n\n## Time Complexity (Analysis)\nQuick Sort is an **unstable** sorting algorithm. However, the worst case is *$O(n^2)*.\n- The best case is *$O(nlogn)*\n- The average case is *$O(nlogn)*\n- The worst case is *$O(n^2)*\n\n## Quick Sort Implementation (Version 2)\nThis second version of Quick Sort will be more efficient as we will be using a **random** pivot within our partition() method. This essentially results into the worst case having an **extremely** low probability of occuring. Therefore, this version of Quick Sort is more efficient.\n\n### Sort Method\nThe sort() method will stay the same as we only have to change the pivot that is chosen.\n\n### Partition Method\nThis will be the updated version of partition() that relies on a random pivot. \n```java\nprivate static <E extends Comparable<? super E>> int partition(E[] arr, int l, int h){\n    int randomIndex = ThreadLocalRandom.current().nextInt(l, h);\n    E pivot = arr[randomIndex];\n    /* use code from previous partition() */\n}\n```\n\n### Time Complexity & Space Complexity (Analysis)\nThis version of Quick Sort is still an **unstable** sorting algorithm.\n- The best case is *$O(nlogn)*\n- The average case is *$O(nlogn)*\n- The worst case is *$O(nlogn)*\n\n## Visualizer\n...And that's it! Our implementation of Quick Sort should be working just fine. Remember, there is also a simple visualization tool for sorting algorithms. Click the button below to check out the visualizer!\n",section:this.sortingSection,nextSectionDirectory:"/AlgoVisual/documentation/sorting/heap-sort",nextSection:!0,nextSectionName:"6. Heap Sort"})}),Object(m.jsx)(j.a,{exact:!0,path:"/AlgoVisual/documentation/sorting/heap-sort",children:Object(m.jsx)(_,{mainDirectory:"/AlgoVisual/documentation/sorting",sections:K,partNumber:6,markdown:"\n# Heap Sort\n",section:this.sortingSection,nextSectionDirectory:"/AlgoVisual/documentation/sorting/analysis-of-sorting-algorithms",nextSection:!0,nextSectionName:"7. Analysis of Sorting Algorithms"})}),Object(m.jsx)(j.a,{exact:!0,path:"/AlgoVisual/documentation/sorting/analysis-of-sorting-algorithms",children:Object(m.jsx)(_,{mainDirectory:"/AlgoVisual/documentation/sorting",sections:K,partNumber:7,markdown:"\n# Analysis of Sorting Algorithms\n",section:this.sortingSection,nextSection:!1})}),Object(m.jsx)(j.a,{exact:!0,path:"/AlgoVisual/documentation/pathfinding",children:Object(m.jsx)($,{section:this.pathfindingSection})})]})]})}}]),n}(r.a.Component),Z=n(18);n(601);function X(e){var t=[];return function(e,t){for(var n=0;n<e.length-1;n++){for(var i=0,r=0;r<e.length-1-n;r++)t.push([r,r+1,!0]),t.push([r,r+1,!0]),e[r]>e[r+1]?(t.push([r,e[r+1],!1]),t.push([r+1,e[r],!1]),ee(e,r,r+1)):i++;if(i===e.length-1)break}}(e,t),t}function ee(e,t,n){var i=e[t];e[t]=e[n],e[n]=i}function te(e){var t=[],n=e.slice();return ne(e,0,e.length-1,n,t),t}function ne(e,t,n,i,r){if(t!==n){var a=Math.floor((t+n)/2);ne(i,t,a,e,r),ne(i,a+1,n,e,r),function(e,t,n,i,r,a){var s=t,o=t,l=n+1;for(;o<=n&&l<=i;)a.push([o,l,!0]),a.push([o,l,!0]),r[o]<=r[l]?(a.push([s,r[o],!1]),e[s++]=r[o++]):(a.push([s,r[l],!1]),e[s++]=r[l++]);for(;o<=n;)a.push([o,o,!0]),a.push([o,o,!0]),a.push([s,r[o],!1]),e[s++]=r[o++];for(;l<=i;)a.push([l,l,!0]),a.push([l,l,!0]),a.push([s,r[l],!1]),e[s++]=r[l++]}(e,t,a,n,i,r)}}function ie(e){var t=[];return re(e,0,e.length-1,t),t}function re(e,t,n,i){if(t<n){var r=function(e,t,n,i){var r,a=(o=t,l=n,Math.floor(Math.random()*(l-o)+o)),s=e[a];var o,l;i.push([a,a,"pivot","insert"]);var c=t-1,h=n+1;for(;;){do{c++,i.push([c,c,"color","insert"]),i.push([c,c,"color","revert"])}while(e[c]<s);do{h--,i.push([h,h,"color","insert"]),i.push([h,h,"color","revert"])}while(e[h]>s);if(c>=h)return i.push([r,r,"pivot","revert"]),h;i.push([c,e[h],"swap","swap"]),i.push([h,e[c],"swap","swap"]),ae(e,c,h),c===a?(i.push([h,h,"pivot","insert"]),r=h):h===a&&(i.push([c,c,"pivot","insert"]),r=c)}}(e,t,n,i);re(e,t,r,i),re(e,r+1,n,i)}}function ae(e,t,n){var i=e[t];e[t]=e[n],e[n]=i}function se(e){var t=[];return function(e,t){for(var n=e.length,i=n/2;i>=1;i--)oe(e,i,n,t);var r=n;for(;r>1;)ce(e,1,r--,t),oe(e,1,r,t)}(e,t),t}function oe(e,t,n,i){for(;2*t<=n;){var r=2*t;if(r<n&&le(e,r,r+1)&&r++,!le(e,t,r))break;ce(e,t,r,i),t=r}}function le(e,t,n){return e[t-1]<e[n-1]}function ce(e,t,n,i){i.push([t-1,t-1,!0]),i.push([t-1,t-1,!0]),i.push([t-1,e[n-1],!1]),i.push([n-1,n-1,!0]),i.push([n-1,n-1,!0]),i.push([n-1,e[t-1],!1]);var r=e[t-1];e[t-1]=e[n-1],e[n-1]=r}function he(e){var t=[];return function(e,t){for(var n=0;n<e.length;n++){for(var i=e[n],r=n,a=n;a<e.length;a++)t.push([a,a,!0]),t.push([a,a,!0]),i>e[a]&&(i=e[a],r=a);t.push([n,e[r],!1]),t.push([r,e[n],!1]),ue(e,n,r)}}(e,t),t}function ue(e,t,n){var i=e[t];e[t]=e[n],e[n]=i}var de=n(620),me="#98d6e8",pe="#33435d",be=["Bubble Sort","Insertion Sort","Selection Sort","Merge Sort","Quick Sort","Heap Sort"],ge=function(e){Object(c.a)(n,e);var t=Object(h.a)(n);function n(e){var r;return Object(o.a)(this,n),(r=t.call(this,e)).dropdownSelection=Object(i.createRef)(),r.dropdownCaret=Object(i.createRef)(),r.runButton=Object(i.createRef)(),r.resetButton=Object(i.createRef)(),r.timer=void 0,r.timer=null,r.state={arr:[],numberOfBars:100,sortingSpeed:1,sortingAlgorithm:"Quick Sort",showSortingOptions:!1,optionsDisabled:!1,animationLength:0,sliderStyle:{color:"#33435d",":hover":{boxShadow:0},"& .MuiSlider-thumb":{bgcolor:"#85a4d9","&:focus, &:hover, &.Mui-active, &.Mui-focusVisible":{boxShadow:"0"}},"& .MuiSlider-valueLabel":{display:"none"}},keepTimeout:!0},r.resetArray=r.resetArray.bind(Object(u.a)(r)),r.changeWidthBasedOnSize=r.changeWidthBasedOnSize.bind(Object(u.a)(r)),r.numberOfBars=r.numberOfBars.bind(Object(u.a)(r)),r.sliderSpeed=r.sliderSpeed.bind(Object(u.a)(r)),r.runSortingAlgorithm=r.runSortingAlgorithm.bind(Object(u.a)(r)),r.buttonEnter=r.buttonEnter.bind(Object(u.a)(r)),r.buttonLeave=r.buttonLeave.bind(Object(u.a)(r)),r.showSortingAlgorithms=r.showSortingAlgorithms.bind(Object(u.a)(r)),r.closeSortingAlgorithms=r.closeSortingAlgorithms.bind(Object(u.a)(r)),r.displaySortingAlgorithms=r.displaySortingAlgorithms.bind(Object(u.a)(r)),r.changeAlgorithm=r.changeAlgorithm.bind(Object(u.a)(r)),r}return Object(l.a)(n,[{key:"componentDidMount",value:function(){var e=this;this.resetArray(),window.addEventListener("resize",(function(){e.resetArray()}),!0)}},{key:"resetArray",value:function(){var e,t,n=this;if(!this.state.optionsDisabled){for(var i=document.getElementById("app-wrapper").clientHeight-document.getElementById("header").clientHeight-document.getElementById("footer").clientHeight-100,r=[],a=0;a<this.state.numberOfBars;a++)r.push((e=5,t=i,Math.floor(Math.random()*(t-e+1)+e)));this.setState({arr:r},(function(){return n.changeWidthBasedOnSize(n.state.arr)}))}}},{key:"changeWidthBasedOnSize",value:function(e){e.length<=20?this.changeBarsWidth(60):e.length<=40?this.changeBarsWidth(35):e.length<=100?this.changeBarsWidth(10):e.length<=150?this.changeBarsWidth(8):e.length<=200?this.changeBarsWidth(5):this.changeBarsWidth(3)}},{key:"changeBarsWidth",value:function(e){for(var t=document.getElementsByClassName("array-bar"),n=0;n<t.length;n++){t[n].style.width=e+"px"}}},{key:"numberOfBars",value:function(e,t){var n=this;this.setState({numberOfBars:t},(function(){n.state.numberOfBars>10&&n.state.numberOfBars<250&&n.resetArray()}))}},{key:"sliderSpeed",value:function(e,t){this.setState({sortingSpeed:t})}},{key:"buttonEnter",value:function(e){this.state.optionsDisabled||(e.currentTarget.style.color="#98d6e8")}},{key:"buttonLeave",value:function(e){this.state.optionsDisabled||(e.currentTarget.style.color="#fff")}},{key:"showSortingAlgorithms",value:function(e){var t=this;this.state.showSortingOptions||(this.setState({showSortingOptions:!0},(function(){return t.displaySortingAlgorithms()})),e.stopPropagation(),document.addEventListener("click",this.closeSortingAlgorithms))}},{key:"closeSortingAlgorithms",value:function(){var e=this;this.setState({showSortingOptions:!1},(function(){return e.displaySortingAlgorithms()})),document.removeEventListener("click",this.closeSortingAlgorithms)}},{key:"displaySortingAlgorithms",value:function(){this.state.showSortingOptions?(this.dropdownSelection.current.style.display="block",this.dropdownCaret.current.style.transform="rotate(180deg)",this.dropdownCaret.current.style.transition="all 250ms linear"):(this.dropdownSelection.current.style.display="none",this.dropdownCaret.current.style.transform="rotate(0deg)",this.dropdownCaret.current.style.transition="all 250ms linear")}},{key:"changeAlgorithm",value:function(e){this.setState({sortingAlgorithm:e})}},{key:"bubbleSort",value:function(){var e=X(this.state.arr);this.sort(e,2)}},{key:"insertionSort",value:function(){var e=function(e){var t=[];return function(e,t){for(var n=1;n<e.length;n++){for(var i=e[n],r=n-1;r>=0&&e[r]>i;)t.push([r+1,r,!0]),t.push([r+1,r,!0]),t.push([r+1,e[r],!1]),e[r+1]=e[r],r--;t.push([r+1,n,!0]),t.push([r+1,n,!0]),t.push([r+1,i,!1]),e[r+1]=i}}(e,t),t}(this.state.arr);this.sort(e,3)}},{key:"selectionSort",value:function(){var e=he(this.state.arr);this.sort(e,2)}},{key:"mergeSort",value:function(){var e=te(this.state.arr);this.sort(e,3)}},{key:"quickSort",value:function(){var e=ie(this.state.arr);this.sortTest(e)}},{key:"heapSort",value:function(){var e=se(this.state.arr);this.sort(e,3)}},{key:"sortTest",value:function(e){var t=this,n=e.length*this.state.sortingSpeed;this.enableSettings(n);for(var i=0;i<e.length;i++){var r=document.getElementsByClassName("array-bar");if(void 0!==r){var a=e[i][2];"color"===a?function(){var n=Object(Z.a)(e[i],2),a=n[0],s=n[1],o=r[a],l=r[s],c="insert"===e[i][3]?pe:me,h=setTimeout((function(){void 0===o&&void 0===l||(o.style.backgroundColor=c,l.style.backgroundColor=c)}),i*t.state.sortingSpeed);void 0!==o&&void 0!==l||clearTimeout(h)}():"swap"===a?function(){var n=Object(Z.a)(e[i],2),a=n[0],s=n[1],o=r[a],l=setTimeout((function(){void 0!==o&&(o.style.height=s+"px")}),i*t.state.sortingSpeed);void 0===o&&clearTimeout(l)}():"pivot"===a&&function(){var n=Object(Z.a)(e[i],2),a=n[0],s=n[1],o=r[a],l=r[s],c="insert"===e[i][3]?"#83f57f":me,h=setTimeout((function(){void 0===o&&void 0===l||(o.style.backgroundColor=c,l.style.backgroundColor=c)}),i*t.state.sortingSpeed);void 0!==o&&void 0!==l||clearTimeout(h)}()}}}},{key:"sort",value:function(e,t){var n=this,i=e.length*this.state.sortingSpeed;this.enableSettings(i);for(var r=0;r<e.length;r++){var a=document.getElementsByClassName("array-bar");if(void 0!==a)e[r][2]?function(){var i=Object(Z.a)(e[r],2),s=i[0],o=i[1],l=a[s],c=a[o],h=r%t===0?pe:me,u=setTimeout((function(){void 0===l&&void 0===c||(l.style.backgroundColor=h,c.style.backgroundColor=h)}),r*n.state.sortingSpeed);void 0!==l&&void 0!==c||clearTimeout(u)}():function(){var t=Object(Z.a)(e[r],2),i=t[0],s=t[1],o=a[i],l=setTimeout((function(){void 0!==o&&(o.style.height=s+"px")}),r*n.state.sortingSpeed);void 0===o&&clearTimeout(l)}()}}},{key:"runSortingAlgorithm",value:function(){var e=this;this.setState({optionsDisabled:!0},(function(){switch(e.state.sortingAlgorithm){case"Bubble Sort":e.bubbleSort();break;case"Insertion Sort":e.insertionSort();break;case"Selection Sort":e.selectionSort();break;case"Merge Sort":e.mergeSort();break;case"Quick Sort":e.quickSort();break;case"Heap Sort":e.heapSort()}}));for(var t=document.getElementsByClassName("sidebar-button"),n=0;n<t.length;n++){var i=t[n];i.style.color="#f5a0a0",i.style.cursor="revert"}this.setState((function(e){return{sliderStyle:{"& .MuiSlider-thumb":{bgcolor:"#f5a0a0",":hover":{boxShadow:0}}}}}))}},{key:"enableSettings",value:function(e){var t=this;setTimeout((function(){t.setState({optionsDisabled:!1,sliderStyle:{color:"#33435d",":hover":{boxShadow:0},"& .MuiSlider-thumb":{bgcolor:"#85a4d9",":hover":{boxShadow:0}},"& .MuiSlider-valueLabel":{display:"none"}}});for(var e=document.getElementsByClassName("sidebar-button"),n=0;n<e.length;n++){var i=e[n];i.style.color="#fff",i.style.cursor="pointer"}}),e)}},{key:"render",value:function(){var e=this,t=this.state.arr.map((function(e,t){return Object(m.jsx)("div",{className:"array-bar",style:{backgroundColor:me,height:e+"px"}},t)}));return Object(m.jsxs)("main",{className:"main-sidebar",children:[Object(m.jsx)("div",{className:"sidebar",children:Object(m.jsxs)("div",{className:"sidebar-settings",children:[Object(m.jsxs)("div",{className:"sidebar-setting",children:[Object(m.jsx)("p",{children:" Control number of bars "}),Object(m.jsxs)("p",{children:[" ",this.state.numberOfBars," bars "]}),Object(m.jsx)(de.a,{sx:this.state.sliderStyle,disabled:this.state.optionsDisabled,min:10,onChange:this.numberOfBars,max:250,defaultValue:100,valueLabelDisplay:"auto"})]}),Object(m.jsxs)("div",{className:"sidebar-setting",children:[Object(m.jsx)("p",{children:" Control visualizer speed "}),Object(m.jsxs)("p",{children:[" ",this.state.sortingSpeed," ms "]}),Object(m.jsx)(de.a,{sx:this.state.sliderStyle,disabled:this.state.optionsDisabled,min:1,onChange:this.sliderSpeed,max:100,defaultValue:1,valueLabelDisplay:"auto"})]}),Object(m.jsxs)("div",{className:"sidebar-setting",children:[Object(m.jsx)("p",{children:" Choose an algorithm "}),Object(m.jsxs)("div",{className:"selection-dropdown",onClick:this.showSortingAlgorithms,children:[Object(m.jsx)("div",{className:"current-option",children:Object(m.jsxs)("p",{children:[" ",this.state.sortingAlgorithm," "]})}),Object(m.jsx)("div",{className:"caret-down",children:Object(m.jsx)("i",{className:"fas fa-caret-down",ref:this.dropdownCaret,children:" "})})]}),Object(m.jsx)("div",{className:"selection-options",ref:this.dropdownSelection,children:Object(m.jsx)("ul",{children:be.map((function(t){return Object(m.jsxs)("div",{onClick:function(){return e.changeAlgorithm(t)},children:[" ",t," "]},t)}))})}),Object(m.jsx)("button",{disabled:this.state.optionsDisabled,className:"sidebar-button",onClick:this.runSortingAlgorithm,onMouseEnter:this.buttonEnter,onMouseLeave:this.buttonLeave,ref:this.runButton,children:" Run"})]}),Object(m.jsxs)("div",{className:"sidebar-setting",children:[Object(m.jsx)("p",{children:" Reset the array "}),Object(m.jsx)("button",{disabled:this.state.optionsDisabled,className:"sidebar-button",onClick:this.resetArray,onMouseEnter:this.buttonEnter,onMouseLeave:this.buttonLeave,ref:this.resetButton,children:" Reset"})]})]})}),Object(m.jsx)("div",{id:"bars-wrapper",children:Object(m.jsx)("div",{id:"bars",children:t})})]})}}]),n}(r.a.Component);var je=function(e){Object(c.a)(n,e);var t=Object(h.a)(n);function n(e){return Object(o.a)(this,n),t.call(this,e)}return Object(l.a)(n,[{key:"render",value:function(){return Object(m.jsx)(d.a,{children:Object(m.jsxs)("div",{id:"app-wrapper",children:[Object(m.jsx)(p,{}),Object(m.jsxs)(j.c,{children:[Object(m.jsx)(j.a,{exact:!0,path:"/AlgoVisual",children:Object(m.jsx)(g,{})}),Object(m.jsx)(j.a,{exact:!0,path:"/AlgoVisual/sorting",children:Object(m.jsx)(ge,{})}),Object(m.jsx)(j.a,{exact:!0,path:"/AlgoVisual/pathfinding"}),Object(m.jsx)(j.a,{path:"/AlgoVisual/documentation",children:Object(m.jsx)(Y,{})}),Object(m.jsx)(j.a,{path:"/AlgoVisual/about"})]}),Object(m.jsx)(b,{})]})})}}]),n}(r.a.Component),fe=function(e){e&&e instanceof Function&&n.e(3).then(n.bind(null,622)).then((function(t){var n=t.getCLS,i=t.getFID,r=t.getFCP,a=t.getLCP,s=t.getTTFB;n(e),i(e),r(e),a(e),s(e)}))};s.a.render(Object(m.jsx)(r.a.StrictMode,{children:Object(m.jsx)(je,{})}),document.getElementById("root")),fe()}},[[603,1,2]]]);
//# sourceMappingURL=main.a277e6db.chunk.js.map